(self.webpackChunkjupyter_ovito=self.webpackChunkjupyter_ovito||[]).push([[406],{1568:(e,n,t)=>{e.exports=t(15),e.exports.version=t(4147).version},8657:(e,n,t)=>{e.exports.j="^0.1.4",t(4147).version},15:(e,n,t)=>{"use strict";t.r(n),t.d(n,{OvitoViewportModel:()=>R,OvitoViewportView:()=>V});var i=t(9285);const r={type:"change"},o={type:"start"},a={type:"end"};class s extends i.EventDispatcher{constructor(e,n){super(),this.object=e,this.domElement=n,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new i.Vector3,this.sceneSizeFactor=1,this.zoomSpeed=.7,this.rotateSpeed=1,this.panSpeed=1,this.keyPanSpeed=7,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:i.MOUSE.ROTATE,MIDDLE:i.MOUSE.DOLLY,RIGHT:i.MOUSE.PAN},this.touches={ONE:i.TOUCH.ROTATE,TWO:i.TOUCH.DOLLY_PAN},this._domElementKeyEvents=null,this.setObject=function(e){t.object=e},this.listenToKeyEvents=function(e){e.addEventListener("keydown",H),this._domElementKeyEvents=e},this.saveState=function(){t.object&&(t.oldMatrix=t.object.matrix.clone(),t.oldMatrixInverse=t.oldMatrix.clone().invert(),t.oldZoom=t.object.zoom)},this.updateSceneSizeFactor=function(e){if(console.assert(!0===e.isBox3),e.isEmpty())t.sceneSizeFactor=1;else{const n=e.getSize(new i.Vector3).length();t.sceneSizeFactor=.0025*n}},this.update=function(){const e=new i.Vector3,n=new i.Vector3;return function(){if(!t.object)return!1;if(e.setFromMatrixPosition(t.oldMatrix),e.add(h),t.object.isPerspectiveCamera&&0!=d){const i=t.sceneSizeFactor*d;n.setFromMatrixColumn(t.oldMatrix,2).normalize(),e.addScaledVector(n,i)}t.object.matrix.copy(t.oldMatrix).setPosition(e);const o=t.object.up.clone().transformDirection(t.oldMatrixInverse);let a,s;a=0==o.x&&0==o.y?Math.PI:Math.atan2(o.x,o.y),s=Math.atan2(Math.sqrt(o.x*o.x+o.y*o.y),o.z);let c=l.phi,u=l.theta;if(s+c<1e-6?c=1e-6-s:s+c>Math.PI-1e-6&&(c=Math.PI-1e-6-s),0!=c||0!=u){const e=t.target,n=e.clone().applyMatrix4(t.oldMatrixInverse),r=(new i.Matrix4).setPosition(e),o=(new i.Matrix4).makeRotationAxis(t.object.up,-u),a=(new i.Matrix4).makeTranslation(-e.x,-e.y,-e.z),s=t.oldMatrix,l=(new i.Matrix4).setPosition(n),d=(new i.Matrix4).makeRotationX(c),h=(new i.Matrix4).makeTranslation(-n.x,-n.y,-n.z);r.multiply(o),r.multiply(a),r.multiply(s),r.multiply(l),r.multiply(d),r.multiply(h),t.object.matrix.copy(r)}t.object.updateMatrixWorld(!0),t.dispatchEvent(r)}}(),this.dispose=function(){t.domElement.removeEventListener("contextmenu",Z),t.domElement.removeEventListener("pointerdown",D),t.domElement.removeEventListener("pointercancel",W),t.domElement.removeEventListener("wheel",U),t.domElement.removeEventListener("pointermove",F),t.domElement.removeEventListener("pointerup",j),null!==t._domElementKeyEvents&&t._domElementKeyEvents.removeEventListener("keydown",H)};const t=this,s=-1;let c=s;const l=new i.Spherical;let d=0;const h=new i.Vector3,u=new i.Vector2,f=new i.Vector2,p=new i.Vector2,m=new i.Vector2,g=new i.Vector2,v=new i.Vector2,y=new i.Vector2,_=new i.Vector2,I=new i.Vector2,b=[],T={};function w(){return Math.pow(.95,t.zoomSpeed)}function L(e){l.theta+=e}function x(e){l.phi-=e}const O=function(){const e=new i.Vector3;return function(n,t){e.setFromMatrixColumn(t,0),e.multiplyScalar(-n),h.add(e)}}(),M=function(){const e=new i.Vector3;return function(n,t){e.setFromMatrixColumn(t,1),e.multiplyScalar(n),h.add(e)}}(),A=function(){const e=new i.Vector3;return function(n,i){const r=t.domElement;if(t.object.isPerspectiveCamera){e.setFromMatrixPosition(t.oldMatrix),e.sub(t.target);let o=e.length();o*=Math.tan(t.object.fov/2*Math.PI/180),O(2*n*o/r.clientHeight,t.object.matrix),M(2*i*o/r.clientHeight,t.object.matrix)}else t.object.isOrthographicCamera&&(O(n*(t.object.right-t.object.left)/t.object.zoom/r.clientWidth,t.object.matrix),M(i*(t.object.top-t.object.bottom)/t.object.zoom/r.clientHeight,t.object.matrix))}}();function G(e){t.object.isPerspectiveCamera?d+=I.y*t.zoomSpeed:t.object.isOrthographicCamera&&(t.object.zoom*=e)}function S(e){t.object.isPerspectiveCamera?d+=I.y*t.zoomSpeed:t.object.isOrthographicCamera&&(t.object.zoom/=e)}function P(e){u.set(e.clientX,e.clientY),t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0}function C(e){m.set(e.clientX,e.clientY),t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0}function N(){if(1===b.length)u.set(b[0].pageX,b[0].pageY);else{const e=.5*(b[0].pageX+b[1].pageX),n=.5*(b[0].pageY+b[1].pageY);u.set(e,n)}}function E(){if(1===b.length)m.set(b[0].pageX,b[0].pageY);else{const e=.5*(b[0].pageX+b[1].pageX),n=.5*(b[0].pageY+b[1].pageY);m.set(e,n)}}function z(){const e=b[0].pageX-b[1].pageX,n=b[0].pageY-b[1].pageY,t=Math.sqrt(e*e+n*n);y.set(0,t)}function Y(e){if(1==b.length)f.set(e.pageX,e.pageY);else{const n=X(e),t=.5*(e.pageX+n.x),i=.5*(e.pageY+n.y);f.set(t,i)}p.subVectors(f,u).multiplyScalar(t.rotateSpeed);const n=t.domElement;L(2*Math.PI*p.x/n.clientHeight),x(2*Math.PI*p.y/n.clientHeight),u.copy(f)}function R(e){if(1===b.length)g.set(e.pageX,e.pageY);else{const n=X(e),t=.5*(e.pageX+n.x),i=.5*(e.pageY+n.y);g.set(t,i)}v.subVectors(g,m).multiplyScalar(t.panSpeed),A(v.x,v.y),m.copy(g)}function V(e){const n=X(e),i=e.pageX-n.x,r=e.pageY-n.y,o=Math.sqrt(i*i+r*r);_.set(0,o),I.set(0,Math.pow(_.y/y.y,t.zoomSpeed)),G(I.y),y.copy(_)}function D(e){!1!==t.enabled&&(0===b.length&&(t.domElement.setPointerCapture(e.pointerId),t.domElement.addEventListener("pointermove",F),t.domElement.addEventListener("pointerup",j)),function(e){b.push(e)}(e),"touch"===e.pointerType?function(e){switch(B(e),b.length){case 1:switch(t.touches.ONE){case i.TOUCH.ROTATE:N(),c=3;break;case i.TOUCH.PAN:E(),c=4;break;default:c=s}break;case 2:switch(t.touches.TWO){case i.TOUCH.DOLLY_PAN:z(),E(),c=5;break;case i.TOUCH.DOLLY_ROTATE:z(),N(),c=6;break;default:c=s}break;default:c=s}c!==s&&t.dispatchEvent(o)}(e):function(e){let n;switch(e.button){case 0:n=t.mouseButtons.LEFT;break;case 1:n=t.mouseButtons.MIDDLE;break;case 2:n=t.mouseButtons.RIGHT;break;default:n=-1}switch(n){case i.MOUSE.DOLLY:!function(e){y.set(e.clientX,e.clientY),t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0}(e),c=1;break;case i.MOUSE.ROTATE:e.ctrlKey||e.metaKey||e.shiftKey?(C(e),c=2):(P(e),c=0);break;case i.MOUSE.PAN:e.ctrlKey||e.metaKey||e.shiftKey?(P(e),c=0):(C(e),c=2);break;default:c=s}c!==s&&t.dispatchEvent(o)}(e))}function F(e){!1!==t.enabled&&("touch"===e.pointerType?function(e){switch(B(e),c){case 3:Y(e),t.update();break;case 4:R(e),t.update();break;case 5:!function(e){V(e),R(e)}(e),t.update();break;case 6:!function(e){V(e),Y(e)}(e),t.update();break;default:c=s}}(e):function(e){if(!1!==t.enabled)switch(c){case 0:!function(e){f.set(e.clientX,e.clientY),p.subVectors(f,u).multiplyScalar(t.rotateSpeed);const n=t.domElement;L(2*Math.PI*p.x/n.clientHeight),x(2*Math.PI*p.y/n.clientHeight),u.copy(f),t.update()}(e);break;case 1:!function(e){_.set(e.clientX,e.clientY),I.subVectors(_,y),I.y>0?G(w()):I.y<0&&S(w()),y.copy(_),t.update()}(e);break;case 2:!function(e){g.set(e.clientX,e.clientY),v.subVectors(g,m).multiplyScalar(t.panSpeed),A(v.x,v.y),m.copy(g),t.update()}(e)}}(e))}function j(e){k(e),0===b.length&&(t.domElement.releasePointerCapture(e.pointerId),t.domElement.removeEventListener("pointermove",F),t.domElement.removeEventListener("pointerup",j)),t.dispatchEvent(a),c=s}function W(e){k(e)}function U(e){!1!==t.enabled&&!1!==t.enableZoom&&c===s&&(e.preventDefault(),t.dispatchEvent(o),function(e){t.saveState(),h.set(0,0,0),l.set(0,0,0),d=0,I.y=e.deltaY,e.deltaY<0?S(w()):e.deltaY>0&&G(w()),t.update()}(e),t.dispatchEvent(a))}function H(e){!1!==t.enabled&&function(e){let n=!1;switch(e.code){case t.keys.UP:A(0,t.keyPanSpeed),n=!0;break;case t.keys.BOTTOM:A(0,-t.keyPanSpeed),n=!0;break;case t.keys.LEFT:A(t.keyPanSpeed,0),n=!0;break;case t.keys.RIGHT:A(-t.keyPanSpeed,0),n=!0}n&&(e.preventDefault(),t.update())}(e)}function Z(e){!1!==t.enabled&&e.preventDefault()}function k(e){delete T[e.pointerId];for(let n=0;n<b.length;n++)if(b[n].pointerId==e.pointerId)return void b.splice(n,1)}function B(e){let n=T[e.pointerId];void 0===n&&(n=new i.Vector2,T[e.pointerId]=n),n.set(e.pageX,e.pageY)}function X(e){const n=e.pointerId===b[0].pointerId?b[1]:b[0];return T[n.pointerId]}t.domElement.addEventListener("contextmenu",Z),t.domElement.addEventListener("pointerdown",D),t.domElement.addEventListener("pointercancel",W),t.domElement.addEventListener("wheel",U,{passive:!1}),t.saveState(),t.update()}}class c{static isWebGLAvailable(){try{const e=document.createElement("canvas");return!(!window.WebGLRenderingContext||!e.getContext("webgl")&&!e.getContext("experimental-webgl"))}catch(e){return!1}}static isWebGL2Available(){try{const e=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!e.getContext("webgl2"))}catch(e){return!1}}static getWebGLErrorMessage(){return this.getErrorMessage(1)}static getWebGL2ErrorMessage(){return this.getErrorMessage(2)}static getErrorMessage(e){const n={1:window.WebGLRenderingContext,2:window.WebGL2RenderingContext};let t='Your $0 does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" style="color:#000">$1</a>';const i=document.createElement("div");return i.id="webglmessage",i.style.fontFamily="monospace",i.style.fontSize="13px",i.style.fontWeight="normal",i.style.textAlign="center",i.style.background="#fff",i.style.color="#000",i.style.padding="1.5em",i.style.width="400px",i.style.margin="5em auto 0",t=n[e]?t.replace("$0","graphics card"):t.replace("$0","browser"),t=t.replace("$1",{1:"WebGL",2:"WebGL 2"}[e]),i.innerHTML=t,i}}const l={zoom_all:{light:"'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmlld0JveD0iMCAwIDUxMiA1MTIiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuOTIuMiA1YzNlODBkLCAyMDE3LTA4LTA2IgogICBzb2RpcG9kaTpkb2NuYW1lPSJ6b29tX3NjZW5lX2V4dGVudHMuYncuc3ZnIj4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGExMCI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczgiIC8+CiAgPHNvZGlwb2RpOm5hbWVkdmlldwogICAgIHBhZ2Vjb2xvcj0iI2ZmZmZmZiIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBib3JkZXJvcGFjaXR5PSIxIgogICAgIG9iamVjdHRvbGVyYW5jZT0iMTAiCiAgICAgZ3JpZHRvbGVyYW5jZT0iMTAiCiAgICAgZ3VpZGV0b2xlcmFuY2U9IjEwIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwIgogICAgIGlua3NjYXBlOnBhZ2VzaGFkb3c9IjIiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxNDQwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9Ijg1NSIKICAgICBpZD0ibmFtZWR2aWV3NiIKICAgICBzaG93Z3JpZD0iZmFsc2UiCiAgICAgaW5rc2NhcGU6em9vbT0iMC45MjE4NzUiCiAgICAgaW5rc2NhcGU6Y3g9IjQ1LjU1OTMxOCIKICAgICBpbmtzY2FwZTpjeT0iMjA1LjE2NTY1IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIxIgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ic3ZnMiIgLz4KICA8cGF0aAogICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgZD0iTSA3NC4yMzQ4ODksMTUxLjE0MzQxIFYgMzQzLjQxMTc2IEwgMjc0LjYxMTMzLDQzMC41MjA5MiA0MzkuOTM0NjEsMzU4LjU5ODIgViAxNTMuMzEyOSBMIDI1Ny4wODQ3NSw4My45MTg0OTYgWiBtIDE4Mi44ODU1ODEsLTIyLjg5NjYgMTM3LjE2NDE4LDUxLjQzNjU3IHYgMC43ODU4NCBMIDI1Ny4xMjA0NywyMzYuMTkyMTcgMTE5Ljk1NjI4LDE4MC40NjkyMiB2IC0wLjc4NTg0IHogbSAyMi44NjA2OSwyNTQuMzI1MjYgViAyNzYuMTk4NCBsIDExNC4zMDM0OSwtNDYuNDM1OCB2IDEwNi41MDUxOSB6IgogICAgIGlkPSJwYXRoNCIKICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNjY2NjY2NjY2NjY2NjY2NjY2MiCiAgICAgc3R5bGU9ImZpbGw6I2Q5ZDlkOTtmaWxsLW9wYWNpdHk6MSIgLz4KICA8cGF0aAogICAgIHN0eWxlPSJjb2xvcjojMDAwMDAwO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6bm9ybWFsO2ZvbnQtc3RyZXRjaDpub3JtYWw7Zm9udC1zaXplOm1lZGl1bTtsaW5lLWhlaWdodDpub3JtYWw7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmb250LXZhcmlhbnQtbGlnYXR1cmVzOm5vcm1hbDtmb250LXZhcmlhbnQtcG9zaXRpb246bm9ybWFsO2ZvbnQtdmFyaWFudC1jYXBzOm5vcm1hbDtmb250LXZhcmlhbnQtbnVtZXJpYzpub3JtYWw7Zm9udC12YXJpYW50LWFsdGVybmF0ZXM6bm9ybWFsO2ZvbnQtZmVhdHVyZS1zZXR0aW5nczpub3JtYWw7dGV4dC1pbmRlbnQ6MDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtZGVjb3JhdGlvbi1saW5lOm5vbmU7dGV4dC1kZWNvcmF0aW9uLXN0eWxlOnNvbGlkO3RleHQtZGVjb3JhdGlvbi1jb2xvcjojMDAwMDAwO2xldHRlci1zcGFjaW5nOm5vcm1hbDt3b3JkLXNwYWNpbmc6bm9ybWFsO3RleHQtdHJhbnNmb3JtOm5vbmU7d3JpdGluZy1tb2RlOmxyLXRiO2RpcmVjdGlvbjpsdHI7dGV4dC1vcmllbnRhdGlvbjptaXhlZDtkb21pbmFudC1iYXNlbGluZTphdXRvO2Jhc2VsaW5lLXNoaWZ0OmJhc2VsaW5lO3RleHQtYW5jaG9yOnN0YXJ0O3doaXRlLXNwYWNlOm5vcm1hbDtzaGFwZS1wYWRkaW5nOjA7Y2xpcC1ydWxlOm5vbnplcm87ZGlzcGxheTppbmxpbmU7b3ZlcmZsb3c6dmlzaWJsZTt2aXNpYmlsaXR5OnZpc2libGU7b3BhY2l0eToxO2lzb2xhdGlvbjphdXRvO21peC1ibGVuZC1tb2RlOm5vcm1hbDtjb2xvci1pbnRlcnBvbGF0aW9uOnNSR0I7Y29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzOmxpbmVhclJHQjtzb2xpZC1jb2xvcjojMDAwMDAwO3NvbGlkLW9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZDlkOWQ5O2ZpbGwtb3BhY2l0eToxO2ZpbGwtcnVsZTpub256ZXJvO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyMDtzdHJva2UtbGluZWNhcDpidXR0O3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjE7Y29sb3ItcmVuZGVyaW5nOmF1dG87aW1hZ2UtcmVuZGVyaW5nOmF1dG87c2hhcGUtcmVuZGVyaW5nOmF1dG87dGV4dC1yZW5kZXJpbmc6YXV0bztlbmFibGUtYmFja2dyb3VuZDphY2N1bXVsYXRlIgogICAgIGQ9Ik0gMjMuNjI2OTUzLDIxLjQ1NzAzMSBWIDEzMC43MTA5NCBoIDIwIFYgNDEuNDU3MDMxIGggOTEuOTY2Nzk3IHYgLTIwIHogbSAzNTIuNzc5Mjk3LDAgdiAyMCBoIDkxLjk2NjggdiA4OS4yNTM5MDkgaCAyMCBWIDIxLjQ1NzAzMSBaIE0gMjMuNjI2OTUzLDM3MS41MjUzOSBWIDQ4Ni4yMDMxMiBIIDEzNS41OTM3NSB2IC0yMCBIIDQzLjYyNjk1MyB2IC05NC42Nzc3MyB6IG0gNDQ0Ljc0NjA5NywwIHYgOTQuNjc3NzMgaCAtOTEuOTY2OCB2IDIwIGggMTExLjk2NjggViAzNzEuNTI1MzkgWiIKICAgICBpZD0icmVjdDgxOSIKICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIiAvPgo8L3N2Zz4K'"},vr_mode:{light:"'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgZmlsbD0iIzAwMDAwMCIKICAgaGVpZ2h0PSIyNCIKICAgdmlld0JveD0iMCAwIDI0IDI0IgogICB3aWR0aD0iMjQiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9InN2Zzk3NjQiCiAgIHNvZGlwb2RpOmRvY25hbWU9InZpZXdwb3J0X3ZyX21vZGUuc3ZnIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIxLjIuMSAoOWM2ZDQxZSwgMjAyMi0wNy0xNCkiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iPgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTk3NzAiPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM5NzY4IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjEwIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwIgogICAgIGd1aWRldG9sZXJhbmNlPSIxMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTkyMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSI5NjYiCiAgICAgaWQ9Im5hbWVkdmlldzk3NjYiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGlua3NjYXBlOnpvb209IjkuODMzMzMzMyIKICAgICBpbmtzY2FwZTpjeD0iNDAuMjcxMTg3IgogICAgIGlua3NjYXBlOmN5PSIxMy41MjU0MjQiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjE3MjgiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjI1IgogICAgIGlua3NjYXBlOndpbmRvdy1tYXhpbWl6ZWQ9IjEiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ic3ZnOTc2NCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOnNob3dwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iI2QxZDFkMSIgLz4KICA8cGF0aAogICAgIGQ9Ik0wIDBoMjR2MjRIMHoiCiAgICAgZmlsbD0ibm9uZSIKICAgICBpZD0icGF0aDk3NjAiIC8+CiAgPGcKICAgICBhcmlhLWxhYmVsPSJWUiIKICAgICBpZD0idGV4dDEwNjYiCiAgICAgc3R5bGU9ImZvbnQtc2l6ZToxNi4zMjM2cHg7bGluZS1oZWlnaHQ6MS4yNTtmaWxsOiNkOWQ5ZDk7c3Ryb2tlLXdpZHRoOjAuNzY1MTcxIj4KICAgIDxwYXRoCiAgICAgICBkPSJNIDExLjc2MDg4NSw2LjA2NTk1NzIgNy42Nzk5ODQ0LDE3LjkzNDA0NCBIIDUuOTc0Mjk1NiBMIDEuODkzMzk1NSw2LjA2NTk1NzIgSCAzLjU4MzE0MzIgTCA2Ljg2Njk5MjYsMTUuOTE3NTA1IDEwLjE1MDg0Miw2LjA2NTk1NzIgWiIKICAgICAgIHN0eWxlPSJmb250LWZhbWlseTpUYWhvbWE7LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjpUYWhvbWEiCiAgICAgICBpZD0icGF0aDI1MDYiIC8+CiAgICA8cGF0aAogICAgICAgZD0ibSAyMi4wOTA2NjMsMTcuOTM0MDQ0IGggLTIuMDQ4NDIxIGwgLTMuNzYyMDgsLTQuNzE4NTQxIGggLTEuODAxMzM0IHYgNC43MTg1NDEgSCAxMi45MDA2NjcgViA2LjA2NTk1NzIgaCAzLjA2MDY3NSBxIDEuMDIwMjI1LDAgMS43MDU2ODksMC4xMTE1ODcxIDAuNjkzNDM0LDAuMTExNTg3MSAxLjMxNTEzNCwwLjUxODA4MyAwLjYyMTY5OSwwLjM5ODUyNTQgMC45ODAzNzIsMS4wMjgxOTU2IDAuMzY2NjQ0LDAuNjI5NjcwMSAwLjM2NjY0NCwxLjU2MjIxOTYgMCwxLjMwNzE2MzUgLTAuNjYxNTUzLDIuMTgzOTE5NSAtMC42NjE1NTIsMC44NzY3NTYgLTEuODAxMzM0LDEuMjk5MTkzIHogTSAxOC42NzkyODUsOS40MDU2MDAxIHEgMCwtMC41MTgwODMgLTAuMTgzMzIxLC0wLjkxNjYwODQgUSAxOC4zMTI2NDIsOC4wODI0OTU4IDE3LjkzMDA1OCw3LjgyNzQzOTUgMTcuNTk1Mjk2LDcuNjA0MjY1MyAxNy4xNDg5NDgsNy41MTY1ODk3IDE2LjcwMjU5OSw3LjQyMDk0MzYgMTYuMDQxMDQ3LDcuNDIwOTQzNiBoIC0xLjU2MjIxOSB2IDQuNDc5NDI1NCBoIDEuMzg2ODY4IHEgMC42Nzc0OTMsMCAxLjIxOTQ4OCwtMC4xMTk1NTcgMC41NDE5OTQsLTAuMTE5NTU4IDAuOTI0NTc5LC0wLjQ5NDE3MiAwLjM0MjczMiwtMC4zMzQ3NjEgMC41MDIxNDIsLTAuNzk3MDUxIDAuMTY3MzgsLTAuNDYyMjg5IDAuMTY3MzgsLTEuMDgzOTg4OSB6IgogICAgICAgc3R5bGU9ImZvbnQtZmFtaWx5OlRhaG9tYTstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOlRhaG9tYSIKICAgICAgIGlkPSJwYXRoMjUwOCIgLz4KICA8L2c+Cjwvc3ZnPgo='"}};var d=t(3379),h=t.n(d),u=t(7795),f=t.n(u),p=t(569),m=t.n(p),g=t(3565),v=t.n(g),y=t(9216),I=t.n(y),b=t(4589),T=t.n(b),w=t(8743),L={};L.styleTagTransform=T(),L.setAttributes=v(),L.insert=m().bind(null,"head"),L.domAPI=f(),L.insertStyleElement=I(),h()(w.Z,L),w.Z&&w.Z.locals&&w.Z.locals;class x{constructor(){this.domElement=document.createElement("div"),this.domElement.style.position="absolute",this.domElement.style.bottom=0,this.domElement.style.right=0,this.domElement.style.zIndex="999"}addButton(e,n){const t=document.createElement("button");t.className="jupyter-ovito-toolbtn",this.domElement.appendChild(t),t.setAttribute("style",`background-image: url(${l[e].light});`),t.addEventListener("click",n)}}class O{constructor(e){this.linesThick=new i.ShaderMaterial({name:"linesThick",vertexColors:!0,vertexShader:t(9439),fragmentShader:t(7836),uniforms:{line_thickness:{value:new i.Vector2}}}),this.spheresAsRaycastingQuads=new i.ShaderMaterial({name:"spheresAsRaycastingQuads",vertexColors:!0,vertexShader:t(9689),fragmentShader:t(e?3268:8338),alphaToCoverage:e,extensions:{fragDepth:!0,derivatives:e}}),this.spheresImposterQuads=new i.ShaderMaterial({name:"spheresImposterQuads",vertexColors:!0,vertexShader:t(3724),fragmentShader:t(e?5636:2923),alphaToCoverage:e,extensions:{derivatives:e}}),this.circles=new i.ShaderMaterial({name:"circles",vertexColors:!0,vertexShader:t(8135),fragmentShader:t(e?8686:5418),alphaToCoverage:e,extensions:{derivatives:e}}),this.cubes=new i.ShaderMaterial({name:"cubes",vertexColors:!0,vertexShader:t(637),fragmentShader:t(5235)}),this.squares=new i.ShaderMaterial({name:"squares",vertexColors:!0,vertexShader:t(5988),fragmentShader:t(798)}),this.ellipsoids=new i.ShaderMaterial({name:"ellipsoids",vertexColors:!0,vertexShader:t(2322),fragmentShader:t(4617),extensions:{fragDepth:!0}}),this.superquadrics=new i.ShaderMaterial({name:"superquadrics",vertexColors:!0,vertexShader:t(538),fragmentShader:t(7098),extensions:{fragDepth:!0}}),this.cylinders=new i.ShaderMaterial({name:"cylinders",vertexColors:!1,vertexShader:t(3568),fragmentShader:t(2293),defines:{SINGLE_CYLINDER_CAP:0},uniforms:{color_map:{value:void 0},color_range_min:{value:void 0},color_range_max:{value:void 0}},extensions:{fragDepth:!0}}),this.cylindersFlat=new i.ShaderMaterial({name:"cylindersFlat",vertexColors:!1,vertexShader:t(8591),fragmentShader:t(6456),uniforms:{color_map:{value:void 0},color_range_min:{value:void 0},color_range_max:{value:void 0}}}),this.arrowHeads=new i.ShaderMaterial({name:"arrowHeads",vertexColors:!1,vertexShader:t(8799),fragmentShader:t(6115),extensions:{fragDepth:!0}}),this.arrowTails=new i.ShaderMaterial({name:"arrowTails",vertexColors:!1,vertexShader:t(4644),fragmentShader:t(2293),defines:{SINGLE_CYLINDER_CAP:1},extensions:{fragDepth:!0}}),this.arrowsFlat=new i.ShaderMaterial({name:"arrowsFlat",vertexColors:!1,vertexShader:t(7298),fragmentShader:t(8132)}),this.mesh=new i.ShaderMaterial({name:"mesh",vertexColors:!0,side:i.DoubleSide,vertexShader:t(4484),fragmentShader:t(7575),uniforms:{color_map:{value:void 0},opacity:{value:void 0},color_range_min:{value:void 0},color_range_max:{value:void 0},selection_color:{value:void 0}}}),this.meshWireframe=new i.ShaderMaterial({name:"meshWireframe",vertexShader:t(1717),fragmentShader:t(2735),uniforms:{wireframe_color:{value:new i.Vector4(.1,.1,.1,1)}}})}dispose(){for(const e in this){const n=this[e];if(n.isMaterial){if(n.dispose(),n.variations)for(const e of n.variations)e.dispose();delete this[e]}}}lookup(e,n){for(const t in n)if(console.assert(void 0!==e[t]),e[t]!==n[t]&&JSON.stringify(e[t])!==JSON.stringify(n[t])){e.variations||(e.variations=[]);for(const t of e.variations){let e=!0;for(const i in n)if(t[i]!==n[i]&&JSON.stringify(t[i])!==JSON.stringify(n[i])){e=!1;break}if(e)return t}const t=e.clone();for(const e in n)t[e]=n[e];return e.variations.push(t),t}return e}}var M=t(1734);function A(e){let n,t;switch(e.targetRayMode){case"tracked-pointer":n=new i.BufferGeometry;const e=.01,r=[.6,.6,.4];return n.setAttribute("position",new i.Float32BufferAttribute([e,0,0,e,0,-1,-e,0,-1,e,0,0,-e,0,-1,-e,0,0],3)),n.setAttribute("color",new i.Float32BufferAttribute([r[0],r[1],r[2],0,0,0,0,0,0,r[0],r[1],r[2],0,0,0,r[0],r[1],r[2]],3)),t=new i.MeshBasicMaterial({vertexColors:!0,blending:i.AdditiveBlending,side:i.DoubleSide}),new i.Mesh(n,t);case"gaze":return n=new i.RingGeometry(.02,.04,32).translate(0,0,-1),t=new i.MeshBasicMaterial({opacity:.5,transparent:!0}),new i.Mesh(n,t)}}function G(e,n){n.fromArray(e)}class S extends i.EventDispatcher{constructor(e){super(),this.addEventListener("camera_changed",(function(n){console.assert(!0===n.camera.isCamera),e.setObject(n.camera)}))}isValid(){return void 0!==this.camera}unpack(e){var n,t;e&&(this.isValid()&&e.perspective==!!this.camera.isPerspectiveCamera||(this.camera=e.perspective?new i.PerspectiveCamera(50,1,1,100):new i.OrthographicCamera(-1,1,1,-1,1,100),this.camera.matrixAutoUpdate=!1,this.dispatchEvent({type:"camera_changed",camera:this.camera})),this.camera.isPerspectiveCamera?this.camera.fov=180*e.fov/Math.PI:this.camera.zoom=1/e.fov,G(e.up,this.camera.up),0==this.camera.up.lengthSq()&&this.camera.up.set(0,0,1),n=e.matrix,(t=this.camera.matrix).elements[0]=n[0][0],t.elements[4]=n[0][1],t.elements[8]=n[0][2],t.elements[12]=n[0][3],t.elements[1]=n[1][0],t.elements[5]=n[1][1],t.elements[9]=n[1][2],t.elements[13]=n[1][3],t.elements[2]=n[2][0],t.elements[6]=n[2][1],t.elements[10]=n[2][2],t.elements[14]=n[2][3],t.elements[3]=0,t.elements[7]=0,t.elements[11]=0,t.elements[15]=1,this.camera.updateMatrixWorld(!0))}pack(){return void 0!==this.camera?{perspective:!!this.camera.isPerspectiveCamera,fov:this.camera.isPerspectiveCamera?this.camera.fov*Math.PI/180:1/this.camera.zoom,matrix:(n=this.camera.matrix,[[n.elements[0],n.elements[4],n.elements[8],n.elements[12]],[n.elements[1],n.elements[5],n.elements[9],n.elements[13]],[n.elements[2],n.elements[6],n.elements[10],n.elements[14]]]),up:(e=this.camera.up,[e.x,e.y,e.z])}:null;var e,n}static computeProjectionParameters(e,n,t){if(void 0===t)return;t.updateWorldMatrix(!0,!1);const r=e.clone().applyMatrix4(t.matrixWorldInverse).expandByScalar(1.01);t.isPerspectiveCamera?(r.min.z<0?(t.far=-r.min.z,t.near=Math.max(-r.max.z,1e-4*t.far)):(t.far=Math.max(r.getSize(new i.Vector3).length(),1),t.near=1e-4*t.far),t.far=Math.max(t.far,1.01*t.near),t.aspect=n):(r.isEmpty()?(t.near=1,t.far=100):(t.near=-r.max.z,t.far=-r.min.z,t.far<=t.near&&(t.far=t.near+1)),t.left=-n,t.right=n),t.updateProjectionMatrix()}zoomToBox(e){if(!e.isEmpty()&&this.camera){if(this.camera.isPerspectiveCamera){const n=.5*e.getSize(new i.Vector3).length()/Math.tan(.5*this.camera.fov*Math.PI/180),t=(new i.Vector3).setFromMatrixColumn(this.camera.matrix,2).normalize(),r=e.getCenter(new i.Vector3).addScaledVector(t,n);this.camera.matrix.setPosition(r)}else{this.camera.updateMatrixWorld(!1);const n=new i.Vector3,t=new i.Box2;for(let i=0;i<8;i++)n.x=1&i?e.max.x:e.min.x,n.y=2&i?e.max.y:e.min.y,n.z=4&i?e.max.z:e.min.z,t.expandByPoint(n.applyMatrix4(this.camera.matrixWorldInverse));const r=Math.max(t.max.X-t.min.x,1e-12),o=Math.max(t.max.y-t.min.y,1e-12),a=this.camera.bottom/this.camera.right;this.camera.zoom=1/.55/(a>o/r?r*a:o),this.camera.matrix.setPosition(e.getCenter(n)),this.camera.updateMatrixWorld(!0)}this.camera.updateMatrixWorld(!0)}}}const P={Float32:Float32Array,Int32:Int32Array,Int64:BigInt64Array,Uint8:Uint8Array},C={lines:function(e,n){const t=new i.BufferGeometry;if(1==n.line_width||n.line_width<=0&&e.renderer.getPixelRatio()<=1){t.setAttribute("position",e.lookupBufferAttribute(n.positions)),n.colors&&t.setAttribute("color",e.lookupBufferAttribute(n.colors));const r=(new i.Color).fromArray(n.uniform_color),o=new i.LineBasicMaterial({color:r});return new i.LineSegments(t,o)}{const r=e.lookupBufferAttribute(n.positions),o=e.lookupBufferAttribute(n.colors),a=r.count/2,s=new Uint32Array(2*a*3),c=new Float32Array(4*a*3),l=new Float32Array(4*a*3),d=new Float32Array(4*a*4);let h=0,u=0,f=0;for(let e=0,t=0;e<a;e++,t+=4){for(let t=0;t<4;t++,h+=3)c[h+0]=r.getX(2*e),c[h+1]=r.getY(2*e),c[h+2]=r.getZ(2*e),l[h+0]=r.getX(2*e+1),l[h+1]=r.getY(2*e+1),l[h+2]=r.getZ(2*e+1),d[f++]=o?o.getX(2*e+(t<2?0:1)):n.uniform_color[0],d[f++]=o?o.getY(2*e+(t<2?0:1)):n.uniform_color[1],d[f++]=o?o.getZ(2*e+(t<2?0:1)):n.uniform_color[2],d[f++]=o?o.getW(2*e+(t<2?0:1)):n.uniform_color[3];for(let e=2;e<4;e++)s[u++]=t,s[u++]=e-1+t,s[u++]=e+t}console.assert(h==c.length),console.assert(u==s.length),console.assert(f==d.length),t.setAttribute("position",new i.BufferAttribute(c,3)),t.setAttribute("position2",new i.BufferAttribute(l,3)),t.setAttribute("color",new i.BufferAttribute(d,4)),t.setIndex(new i.BufferAttribute(s,1,!1));const p=n.line_width<=0?e.renderer.getPixelRatio():n.line_width,m=new i.Mesh(t,e.materials.linesThick);return m.onBeforeRender=function(e,n,t,r,o,a){const s=e.getCurrentViewport(new i.Vector4);o.uniforms.line_thickness.value.x=p/s.w,o.uniforms.line_thickness.value.y=p/s.z,o.uniformsNeedUpdate=!0},m.frustumCulled=!1,m}},particles:function(e,n){const t=e.lookupBufferAttribute(n.positions),r=e.lookupBufferAttribute(n.indices),o=e.lookupBufferAttribute(n.colors),a=e.lookupBufferAttribute(n.transparencies),s=e.lookupBufferAttribute(n.radii),c=e.lookupBufferAttribute(n.aspherical_shapes),l=e.lookupBufferAttribute(n.orientations),d=e.lookupBufferAttribute(n.roundness),h=r?r.count:t.count;let u,f,p,m,g,v=null;const y=new i.BufferGeometry;if("spherical"==n.shape){"normal"==n.shading_mode?v="low"!==n.rendering_quality?e.materials.spheresAsRaycastingQuads:e.materials.spheresImposterQuads:"flat"==n.shading_mode&&(v=e.materials.circles),u=new Uint32Array(6*h),f=new Float32Array(4*h*3),p=new Float32Array(4*h),m=new Float32Array(4*h*4);let i=0,c=0,l=0,d=0;for(let e=0,g=0;e<h;e++,g+=4){let h=r?r.array[e]:e,v=a?1-a.array[h]:1,y=s?s.array[h]:n.uniform_radius;for(let e=0;e<4;e++)f[i++]=t.getX(h),f[i++]=t.getY(h),f[i++]=t.getZ(h),m[l++]=o?o.getX(h):n.uniform_color[0],m[l++]=o?o.getY(h):n.uniform_color[1],m[l++]=o?o.getZ(h):n.uniform_color[2],m[l++]=v,p[d++]=y;for(let e=2;e<4;e++)u[c++]=g,u[c++]=e-1+g,u[c++]=e+g}console.assert(i==f.length),console.assert(c==u.length),console.assert(l==m.length),console.assert(d==p.length)}else if("square_cubic"==n.shape||"box"==n.shape||"ellipsoid"==n.shape||"superquadric"==n.shape)if("normal"==n.shading_mode){let p,_;"ellipsoid"==n.shape?(v=e.materials.ellipsoids,p=new Float32Array(24*h*16)):"superquadric"==n.shape?(v=e.materials.superquadrics,p=new Float32Array(24*h*16),_=new Float32Array(24*h*2)):v=e.materials.cubes,u=new Uint32Array(36*h),f=new Float32Array(24*h*3),g=new Float32Array(24*h*3),m=new Float32Array(24*h*4);let I=0,b=0,T=0,w=0,L=0,x=0;for(let e=0;e<h;e++){let i=r?r.array[e]:e,h=a?1-a.array[i]:1,v=s?s.array[i]:n.uniform_radius,y=c?[c.getX(i),c.getY(i),c.getZ(i)]:[v,v,v];0==y[0]&&0==y[1]&&0==y[1]&&(y=[v,v,v]);let O=t.getX(i),M=t.getY(i),A=t.getZ(i),G=0,S=0,P=0,C=1;if(l){G=l.getX(i),S=l.getY(i),P=l.getZ(i),C=l.getW(i);let e=Math.sqrt(G*G+S*S+P*P+C*C);e>=1e-9?(G/=e,S/=e,P/=e,C/=e):C=1}const N=[[y[0],0,0],[0,y[1],0],[0,0,y[2]]];for(let e=0;e<3;e++){const n=N[e][0],t=N[e][1],i=N[e][2],r=C*n+S*i-P*t,o=C*t+P*n-G*i,a=C*i+G*t-S*n,s=-G*n-S*t-P*i;N[e]=[r*C+s*-G+o*-P-a*-S,o*C+s*-S+a*-G-r*-P,a*C+s*-P+r*-S-o*-G]}for(let e=0;e<3;e++)for(let t=-1;t<2;t+=2){for(let r=0;r<4;r++)if(g[b++]=t*N[e][0]/y[e],g[b++]=t*N[e][1]/y[e],g[b++]=t*N[e][2]/y[e],m[T++]=o?o.getX(i):n.uniform_color[0],m[T++]=o?o.getY(i):n.uniform_color[1],m[T++]=o?o.getZ(i):n.uniform_color[2],m[T++]=h,p){for(let e=0;e<3;e++)p[L++]=N[e][0],p[L++]=N[e][1],p[L++]=N[e][2],p[L++]=1;p[L++]=O,p[L++]=M,p[L++]=A,p[L++]=1,_&&(_[x++]=d?d.getX(i):1,_[x++]=d?d.getY(i):1)}let r=I/3;u[w++]=r,u[w++]=r+1,u[w++]=r+2,u[w++]=r,u[w++]=r+2,u[w++]=r+3,f[I++]=O+t*(N[e][0]+N.at(e-1)[0])-N.at(e-2)[0],f[I++]=M+t*(N[e][1]+N.at(e-1)[1])-N.at(e-2)[1],f[I++]=A+t*(N[e][2]+N.at(e-1)[2])-N.at(e-2)[2],f[I++]=O+t*(N[e][0]-N.at(e-1)[0])-N.at(e-2)[0],f[I++]=M+t*(N[e][1]-N.at(e-1)[1])-N.at(e-2)[1],f[I++]=A+t*(N[e][2]-N.at(e-1)[2])-N.at(e-2)[2],f[I++]=O+t*(N[e][0]-N.at(e-1)[0])+N.at(e-2)[0],f[I++]=M+t*(N[e][1]-N.at(e-1)[1])+N.at(e-2)[1],f[I++]=A+t*(N[e][2]-N.at(e-1)[2])+N.at(e-2)[2],f[I++]=O+t*(N[e][0]+N.at(e-1)[0])+N.at(e-2)[0],f[I++]=M+t*(N[e][1]+N.at(e-1)[1])+N.at(e-2)[1],f[I++]=A+t*(N[e][2]+N.at(e-1)[2])+N.at(e-2)[2]}}console.assert(I==f.length),console.assert(w==u.length),console.assert(b==g.length),console.assert(T==m.length),p&&(console.assert(L==p.length),y.setAttribute("shape_orientation",new i.BufferAttribute(p,16))),_&&(console.assert(x==_.length),y.setAttribute("roundness",new i.BufferAttribute(_,2)))}else if("flat"==n.shading_mode&&"square_cubic"==n.shape){v=e.materials.squares,u=new Uint32Array(6*h),f=new Float32Array(4*h*3),p=new Float32Array(4*h),m=new Float32Array(4*h*4);let i=0,c=0,l=0,d=0;for(let e=0,g=0;e<h;e++,g+=4){let h=r?r.array[e]:e,v=a?1-a.array[h]:1,y=s?s.array[h]:n.uniform_radius;for(let e=0;e<4;e++)f[i++]=t.getX(h),f[i++]=t.getY(h),f[i++]=t.getZ(h),m[l++]=o?o.getX(h):n.uniform_color[0],m[l++]=o?o.getY(h):n.uniform_color[1],m[l++]=o?o.getZ(h):n.uniform_color[2],m[l++]=v,p[d++]=y;for(let e=2;e<4;e++)u[c++]=g,u[c++]=e-1+g,u[c++]=e+g}console.assert(i==f.length),console.assert(c==u.length),console.assert(l==m.length),console.assert(d==p.length)}if(!v)return null;y.setAttribute("position",new i.BufferAttribute(f,3)),y.setAttribute("color",new i.BufferAttribute(m,4)),p&&y.setAttribute("radius",new i.BufferAttribute(p,1)),g&&y.setAttribute("normal",new i.BufferAttribute(g,3)),u&&y.setIndex(new i.BufferAttribute(u,1,!1));const _=new i.Mesh(y,v);return _.frustumCulled=!1,v.alphaToCoverage&&(_.onBeforeRender=function(e){e.getContext().colorMask(!0,!0,!0,!1)},_.onAfterRender=function(e){e.getContext().colorMask(!0,!0,!0,!0)}),_},cylinders:function(e,n){const t=e.lookupBufferAttribute(n.base_positions),r=e.lookupBufferAttribute(n.head_positions),o=e.lookupBufferAttribute(n.colors),a=e.lookupBufferAttribute(n.transparencies),s=e.lookupBufferAttribute(n.widths),c={defines:{SINGLE_CYLINDER_CAP:0}};let l,d,h,u,f,p,m,g=null;const v=new i.BufferGeometry;if("normal"==n.shading_mode){"cylinder"==n.shape?(g=e.materials.cylinders,n.single_cap&&Object.apply(c.defines,{SINGLE_CYLINDER_CAP:1})):"arrow"==n.shape&&(g=e.materials.arrowTails);const v=t.count,y=24,_=12,I=new i.Vector3,b=new i.Vector3,T=new i.Vector3,w=new i.Vector3,L=new i.Vector3,x=[T,w,L];l=new Uint32Array(3*_*v),d=new Float32Array(3*y*v),p=new Float32Array(3*y*v),m=new Float32Array(3*y*v),h=new Float32Array(4*y*v),u=new Float32Array(4*y*v),f=new Float32Array(y*v);let O=0,M=0,A=0,G=0,S=0;for(let e=0;e<v;e++){const i=a?1-a.array[e]:1,c=.5*(s?s.array[e]:n.uniform_width);I.fromBufferAttribute(t,e),b.fromBufferAttribute(r,e),L.subVectors(b,I),0!==L.x||0!==L.y||0!==L.z?(0!==L.x||0!==L.y?T.set(L.y,-L.x,0).setLength(c):T.set(-L.z,0,L.x).setLength(c),w.crossVectors(L,T).setLength(c),L.multiplyScalar(.5)):(T.setScalar(0),w.setScalar(0));const g=I.x+L.x,v=I.y+L.y,y=I.z+L.z;let _,P,C,N,E,z;o?o.count==t.count?(_=N=o.getX(e),P=E=3==o.itemSize?o.getY(e):0,C=z=3==o.itemSize?o.getZ(e):0):(_=o.getX(2*e),P=3==o.itemSize?o.getY(2*e):0,C=3==o.itemSize?o.getZ(2*e):0,N=o.getX(2*e+1),E=3==o.itemSize?o.getY(2*e+1):0,z=3==o.itemSize?o.getZ(2*e+1):0):(_=N=n.uniform_color[0],P=E=n.uniform_color[1],C=z=n.uniform_color[2]);for(let e=0;e<3;e++)for(let n=-1;n<2;n+=2){for(let e=0;e<4;e++,M+=4,S+=3)h[M+0]=_,h[M+1]=P,h[M+2]=C,h[M+3]=i,u[M+0]=N,u[M+1]=E,u[M+2]=z,u[M+3]=i,p[S+0]=I.x,p[S+1]=I.y,p[S+2]=I.z,m[S+0]=b.x,m[S+1]=b.y,m[S+2]=b.z,f[G++]=c;let t=O/3;l[A++]=t,l[A++]=t+1,l[A++]=t+2,l[A++]=t,l[A++]=t+2,l[A++]=t+3,d[O++]=g+n*(x[e].x+x.at(e-1).x)-x.at(e-2).x,d[O++]=v+n*(x[e].y+x.at(e-1).y)-x.at(e-2).y,d[O++]=y+n*(x[e].z+x.at(e-1).z)-x.at(e-2).z,d[O++]=g+n*(x[e].x-x.at(e-1).x)-x.at(e-2).x,d[O++]=v+n*(x[e].y-x.at(e-1).y)-x.at(e-2).y,d[O++]=y+n*(x[e].z-x.at(e-1).z)-x.at(e-2).z,d[O++]=g+n*(x[e].x-x.at(e-1).x)+x.at(e-2).x,d[O++]=v+n*(x[e].y-x.at(e-1).y)+x.at(e-2).y,d[O++]=y+n*(x[e].z-x.at(e-1).z)+x.at(e-2).z,d[O++]=g+n*(x[e].x+x.at(e-1).x)+x.at(e-2).x,d[O++]=v+n*(x[e].y+x.at(e-1).y)+x.at(e-2).y,d[O++]=y+n*(x[e].z+x.at(e-1).z)+x.at(e-2).z}}console.assert(O==d.length),console.assert(A==l.length),console.assert(M==h.length),console.assert(G==f.length),console.assert(S==p.length)}else if("flat"==n.shading_mode){let c,v;"cylinder"==n.shape?(g=e.materials.cylindersFlat,c=4,v=2):"arrow"==n.shape&&(g=e.materials.arrowsFlat,c=7,v=5);const y=t.count,_=new i.Vector3,I=new i.Vector3;l=new Uint32Array(3*v*y),d=new Float32Array(3*c*y),p=new Float32Array(3*c*y),m=new Float32Array(3*c*y),h=new Float32Array(4*c*y),u=new Float32Array(4*c*y),f=new Float32Array(c*y);let b=0,T=0,w=0,L=0;for(let e=0;e<y;e++){const i=a?1-a.array[e]:1,d=.5*(s?s.array[e]:n.uniform_width),g=o?o.getX(e):n.uniform_color[0],y=o?o.getY(e):n.uniform_color[1],x=o?o.getZ(e):n.uniform_color[2];_.fromBufferAttribute(t,e),I.fromBufferAttribute(r,e);for(let e=0;e<c;e++,b+=4,L+=3)h[b+0]=g,h[b+1]=y,h[b+2]=x,h[b+3]=i,u[b+0]=g,u[b+1]=y,u[b+2]=x,u[b+3]=i,p[L+0]=_.x,p[L+1]=_.y,p[L+2]=_.z,m[L+0]=I.x,m[L+1]=I.y,m[L+2]=I.z,f[w++]=d;let O=e*c;for(let e=0;e<v;e++)l[T++]=O,l[T++]=O+1+e,l[T++]=O+2+e}console.assert(T==l.length),console.assert(b==h.length),console.assert(w==f.length),console.assert(L==p.length)}if(!g)return null;v.setAttribute("position",new i.BufferAttribute(d,3)),v.setAttribute("base",new i.BufferAttribute(p,3)),v.setAttribute("head",new i.BufferAttribute(m,3)),v.setAttribute("color1",new i.BufferAttribute(h,4)),v.setAttribute("color2",new i.BufferAttribute(u,4)),v.setAttribute("radius",new i.BufferAttribute(f,1)),v.setIndex(new i.BufferAttribute(l,1,!1));const y=new i.Mesh(v,g);if(y.frustumCulled=!1,"arrow"===n.shape&&"normal"===n.shading_mode){const n=new i.Mesh(v,e.materials.arrowHeads);n.frustumCulled=!1,y.add(n)}if(n.pseudocolor_gradient){Object.assign(c.defines,{USE_PSEUDOCOLORS:1});const t=e.lookupTexture(n.pseudocolor_gradient),i=n.pseudocolor_range;y.onBeforeRender=function(e,n,r,o,a,s){a.uniforms.color_map.value=t,a.uniforms.color_range_min.value=i[0],a.uniforms.color_range_max.value=i[1],a.uniformsNeedUpdate=!0}}return y.material=e.materials.lookup(y.material,c),console.assert(y.material===e.materials.lookup(y.material,c)),y},mesh:function(e,n){const t=new i.BufferGeometry,r=new i.InterleavedBuffer(new Float32Array(n.render_vertices.data.buffer),n.render_vertices.components);console.assert(r.count==n.render_vertices.size),t.setAttribute("position",new i.InterleavedBufferAttribute(r,3,0,!1)),t.setAttribute("normal",new i.InterleavedBufferAttribute(r,3,3,!1)),t.setAttribute("color",new i.InterleavedBufferAttribute(r,4,6,!1));const o=e.lookupBufferAttribute(n.instance_matrices),a=e.lookupBufferAttribute(n.instance_colors),s=o?new i.InstancedMesh(t,e.materials.mesh,o.count):new i.Mesh(t,e.materials.mesh),c={side:n.backface_culling?i.FrontSide:i.DoubleSide};if(!1===n.is_fully_opaque&&(c.transparent=!0),n.pseudocolor_gradient){c.defines={USE_PSEUDOCOLORS:1};const t=e.lookupTexture(n.pseudocolor_gradient),i=n.uniform_color[3],r=n.pseudocolor_range,o=n.selection_color;s.onBeforeRender=function(e,n,a,s,c,l){c.uniforms.color_map.value=t,c.uniforms.opacity.value=i,c.uniforms.color_range_min.value=r[0],c.uniforms.color_range_max.value=r[1],c.uniforms.selection_color.value=o,c.uniformsNeedUpdate=!0}}if(o){if(a){s.instanceColor=new i.InstancedBufferAttribute(new Float32Array(3*a.count),3);for(let e=0;e<a.count;e++)s.instanceColor.array[3*e+0]=a.array[4*e+0],s.instanceColor.array[3*e+1]=a.array[4*e+1],s.instanceColor.array[3*e+2]=a.array[4*e+2]}for(let e=0;e<o.count;e++){for(let n=0;n<4;n++)for(let t=0;t<3;t++)s.instanceMatrix.array[16*e+4*n+t]=o.array[12*e+3*n+t];s.instanceMatrix.array[16*e+0+3]=0,s.instanceMatrix.array[16*e+4+3]=0,s.instanceMatrix.array[16*e+8+3]=0,s.instanceMatrix.array[16*e+12+3]=1}}if(n.wireframe_lines){const t=o?new i.InstancedBufferGeometry:new i.BufferGeometry;o&&(t.instanceCount=o.count,t.setAttribute("instanceMatrix",s.instanceMatrix)),t.setAttribute("position",e.lookupBufferAttribute(n.wireframe_lines)),c.polygonOffset=!0,c.polygonOffsetFactor=1,c.polygonOffsetUnits=1;const r={};o&&(r.defines={USE_INSTANCING:1});const a=n.uniform_color[3];a<1&&(r.transparent=!0);const l=new i.LineSegments(t,e.materials.lookup(e.materials.meshWireframe,r));l.onBeforeRender=function(e,n,t,i,r,o){r.uniforms.wireframe_color.value.w=a,r.uniformsNeedUpdate=!0},s.add(l)}return s.material=e.materials.lookup(s.material,c),console.assert(s.material===e.materials.lookup(s.material,c)),s}};class N extends i.EventDispatcher{constructor(e,n){super(),this.materials=e,this.renderer=n,this.scene=new i.Scene,this.primitivesContainer=new i.Group,this.primitivesContainer.boundingBox=new i.Box3,this.scene.add(this.primitivesContainer),this.datasetContainer=new i.Group,this.datasetContainer.add(this.primitivesContainer),this.scene.add(this.datasetContainer),this.vrContainer=new i.Group,this.vrContainer.visible=!1,this.scene.add(this.vrContainer),this.vrCamera=new i.PerspectiveCamera,this.vrCamera.matrixAutoUpdate=!1,this.vrContainer.add(new i.HemisphereLight(6316128,4210752));const t=new i.DirectionalLight(16777215);t.position.set(1,1,1).normalize(),this.vrContainer.add(t),this.buffers=new Map,this.textures=new Map}dispose(){this.scene.traverse((function(e){e.isMesh&&e.geometry.dispose()})),delete this.primitivesContainer,delete this.datasetContainer,delete this.vrContainer,delete this.scene}getBoundingBox(){let e=this.primitivesContainer.boundingBox.clone().applyMatrix4(this.primitivesContainer.matrixWorld);return this.vrContainer.visible&&e.expandByObject(this.vrContainer,!1),e}unpackDataArrays(e){this.textures.forEach((function(e){e.dispose()})),this.buffers.clear(),this.textures.clear();for(const n in e){const t=e[n],r=P[t.type];if(void 0!==r)if(Array.isArray(t.size)){const e=new i.DataTexture(new r(t.data.buffer,t.data.byteOffset,t.data.byteLength/r.BYTES_PER_ELEMENT),t.size[0],t.size[1]);e.needsUpdate=!0,this.textures.set(parseInt(n),e)}else console.assert(r.BYTES_PER_ELEMENT*t.size*t.components===t.data.byteLength),this.buffers.set(parseInt(n),new i.BufferAttribute(new r(t.data.buffer,t.data.byteOffset,t.data.byteLength/r.BYTES_PER_ELEMENT),t.components,!1));else console.error("Unsupported data array type:",t.type)}}unpack(e){if(this.primitivesContainer.traverse((function(e){e.isMesh&&e.geometry.dispose()})),this.primitivesContainer.clear(),this.unpackDataArrays(e.arrays||{}),!_.isEmpty(e)){for(const n of e.objects){const e=C[n.primitive_type];if(void 0===e){console.log("Encountered unsupported rendering primitive type in scene model: primitive_type="+n.primitive_type);continue}const t=e(this,n);void 0!==t&&(t.matrixAutoUpdate=!1,t.frustumCulled=!1,this.primitivesContainer.add(t),t.matrix.fromArray(n.model_view_tm.flat()),t.updateMatrixWorld(!0))}this.primitivesContainer.boundingBox.min.fromArray(e.bounding_box[0]),this.primitivesContainer.boundingBox.max.fromArray(e.bounding_box[1]),this.dispatchEvent({type:"bounding_box_changed",bounding_box:this.primitivesContainer.boundingBox})}}lookupBufferAttribute(e){if(!e)return null;if(e.isBufferAttribute)return e;const n=this.buffers.get(e);return void 0===n&&console.error("Non-existent buffer ID:",e),n}lookupTexture(e){if(!e)return null;const n=this.textures.get(e);return void 0===n&&console.error("Non-existent texture ID:",e),n}}var E=t(6382),z=t(5431),Y=t(8657).j;i.Object3D.DefaultUp=new i.Vector3(0,0,1);class R extends E.DOMWidgetModel{defaults(){return z.extend(E.DOMWidgetModel.prototype.defaults.call(this),{_model_name:"OvitoViewportModel",_view_name:"OvitoViewportView",_model_module:"jupyter-ovito",_view_module:"jupyter-ovito",_model_module_version:Y,_view_module_version:Y,camera_params:null,orbit_center:[0,0,0],scene:{},enable_vr:!1,antialiasing:!1,vr_scale:1})}}class V extends E.DOMWidgetView{render(){try{const n=this;if(!c.isWebGLAvailable())return this.$el.empty().append(c.getWebGLErrorMessage()),this;this.renderer=new i.WebGLRenderer({sortObjects:!1,antialias:this.model.get("antialiasing")}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.xr.enabled=this.model.get("enable_vr"),this.$el.empty().append(this.renderer.domElement),this.el.style.position="relative",this.renderer.domElement.style.width="100%",this.renderer.domElement.style.height="100%",this.materials=new O(this.model.get("antialiasing")),this.scene_manager=new N(this.materials,this.renderer),this.orbit_controls=new s(null,this.renderer.domElement),this.orbit_controls.addEventListener("change",this.renderScene.bind(this)),this.orbit_controls.addEventListener("end",this.sendCamera.bind(this)),this.scene_manager.addEventListener("bounding_box_changed",(function(e){n.orbit_controls.updateSceneSizeFactor(e.bounding_box)})),this.camera=new S(this.orbit_controls),this.toolbar=new x,this.el.appendChild(this.toolbar.domElement),(e=this).renderer.xr.enabled&&"xr"in navigator&&navigator.xr.isSessionSupported("immersive-vr").then((function(n){if(!n)return;const t=new i.Mesh(new i.CircleGeometry(.25,32).rotateX(-Math.PI/2),new i.MeshBasicMaterial({color:10518656}));let r;function o(){this.userData.isSelecting=!0}function a(){if(!0===this.userData.isSelecting){t.position.x=0,t.position.z=0,t.visible=!1;const e=(new i.Vector3).setFromMatrixPosition(this.matrix),n=(new i.Vector3).setFromMatrixColumn(this.matrix,2).normalize();n.y*Math.sign(e.y)>.1&&(t.position.x=e.x-n.x/n.y,t.position.z=e.z-n.z/n.y,t.visible=!0)}this.userData.isSqueezing}function s(){if(this.userData.isSelecting=!1,t.visible){t.visible=!1;const n={x:-t.position.x,y:-t.position.y,z:-t.position.z,w:1},o=new i.Quaternion,a=new XRRigidTransform(n,o),s=r.getOffsetReferenceSpace(a);e.renderer.xr.setReferenceSpace(s)}t.position.x=0,t.position.z=0}t.visible=!1,e.scene_manager.vrContainer.add(t),e.renderer.xr.addEventListener("sessionstart",(()=>r=e.renderer.xr.getReferenceSpace()));const c=new M.i;for(let n=0;n<2;n++){const t=e.renderer.xr.getController(n);t.addEventListener("selectstart",o),t.addEventListener("selectend",s),t.addEventListener("move",a),t.addEventListener("connected",(function(e){this.add(A(e.data)),this.children[0].geometry.boundingBox=new i.Box3(new i.Vector3(0,0,-1),new i.Vector3(0,0,0)),this.children[0].frustumCulled=!1})),t.addEventListener("disconnected",(function(){this.children[0].geometry.dispose(),this.remove(this.children[0])})),e.scene_manager.vrContainer.add(t);const r=e.renderer.xr.getControllerGrip(n);r.add(c.createControllerModel(r)),e.scene_manager.vrContainer.add(r)}e.toolbar.addButton("vr_mode",(function(){if(null===e.renderer.xr.getSession()){const n={optionalFeatures:["local-floor","bounded-floor"]};navigator.xr.requestSession("immersive-vr",n).then(e.renderer.xr.setSession.bind(e.renderer.xr))}else e.renderer.xr.getSession().end()}))})),this.toolbar.addButton("zoom_all",this.zoomAll.bind(this)),this.renderer.xr.addEventListener("sessionstart",this.onWebXRSessionStarted.bind(this)),this.renderer.xr.addEventListener("sessionend",this.onWebXRSessionStopped.bind(this)),G(this.model.get("orbit_center"),n.orbit_controls.target),this.listenTo(this.model,"change:orbit_center",(function(e,n,t){t&&t.ignore_frontend||G(n)})),this.camera.unpack(this.model.get("camera_params")),this.listenTo(this.model,"change:camera_params",(function(e,t,i){i&&i.ignore_frontend||(n.camera.unpack(t),n.renderScene())})),this.scene_manager.unpack(this.model.get("scene")),this.listenTo(this.model,"change:scene",(function(e,t,i){n.scene_manager.unpack(t),n.renderScene()}))}catch(e){throw console.error(e),e}var e;return this}remove(){this.teardownRenderer(),super.remove()}teardownRenderer(){this.stopListening(this.model),this.offscreenRenderTarget&&this.offscreenRenderTarget.dispose(),delete this.offscreenRenderTarget,this.materials&&this.materials.dispose(),delete this.materials,this.scene_manager&&this.scene_manager.dispose(),delete this.scene_manager,delete this.orbit_controls,delete this.camera,this.renderer&&(this.renderer.forceContextLoss(),this.renderer.dispose()),delete this.renderer,delete this.toolbar,delete this.pickingBufferUpToDate,this.$el.empty()}sendCamera(){this.model.set("camera_params",this.camera.pack(),{ignore_frontend:!0}),this.touch()}onWebXRSessionStarted(){this.scene_manager.primitivesContainer.scale.setScalar(this.model.get("vr_scale")),this.scene_manager.primitivesContainer.quaternion.setFromUnitVectors(new i.Vector3(0,0,1),new i.Vector3(0,1,0)),this.scene_manager.primitivesContainer.updateWorldMatrix(!0,!0),this.scene_manager.vrContainer.visible=!0,this.renderer.setAnimationLoop(this.renderScene.bind(this))}onWebXRSessionStopped(){this.renderer.setAnimationLoop(null),this.scene_manager.vrContainer.visible=!1,this.scene_manager.primitivesContainer.scale.setScalar(1),this.scene_manager.primitivesContainer.position.setScalar(0),this.scene_manager.primitivesContainer.quaternion.identity(),this.scene_manager.datasetContainer.scale.setScalar(1),this.scene_manager.datasetContainer.position.setScalar(0),this.scene_manager.datasetContainer.quaternion.identity(),this.scene_manager.datasetContainer.updateWorldMatrix(!0,!0),setTimeout(this.renderScene.bind(this))}zoomAll(){this.camera.zoomToBox(this.scene_manager.getBoundingBox()),this.sendCamera(),this.renderScene()}renderScene(){const e=this.el.clientWidth,n=this.el.clientHeight;if(e&&n&&this.camera.isValid()){let t;!0===this.renderer.xr.isPresenting?(t=this.scene_manager.vrCamera,t.matrix.copy(this.renderer.xr.getCamera().matrix)):(t=this.camera.camera,this.renderer.setDrawingBufferSize(e,n,window.devicePixelRatio),this.pickingBufferUpToDate=!1),S.computeProjectionParameters(this.scene_manager.getBoundingBox(),e/n,t),this.renderer.render(this.scene_manager.scene,t)}}renderPickingBuffer(){const e=this.renderer.getDrawingBufferSize(new i.Vector2);return!!(e.x&&e.y&&this.camera.isValid())&&(void 0===this.offscreenRenderTarget?this.offscreenRenderTarget=new i.WebGLRenderTarget(e.x,e.y):this.offscreenRenderTarget.width===e.x&&this.offscreenRenderTarget.height===e.y||this.offscreenRenderTarget.setSize(e.x,e.y),this.renderer.setRenderTarget(this.offscreenRenderTarget),this.renderer.render(this.scene_manager.scene,this.camera.camera),this.renderer.readRenderTargetPixels(this.offscreenRenderTarget),this.renderer.setRenderTarget(null),this.pickingBufferUpToDate=!0,!0)}pickObject(e,n){if(!0!==this.pickingBufferUpToDate){if(!this.renderPickingBuffer())return null;console.assert(!0===this.pickingBufferUpToDate)}const t=new Uint8Array(4);return this.renderer.readRenderTargetPixels(this.offscreenRenderTarget,e,n,1,1,t),t}onPointerMove(e){const n=e.target.getBoundingClientRect(),t=this.renderer.getPixelRatio(),i=t*(e.clientX-n.left),r=t*(n.bottom-e.clientY);this.statusDisplay.textContent="("+i+", "+r+"): "+this.pickObject(i,r)}processPhosphorMessage(e){super.processPhosphorMessage(e),"resize"===e.type&&window.requestAnimationFrame(this.renderScene.bind(this))}processLuminoMessage(e){super.processLuminoMessage(e),"resize"===e.type&&window.requestAnimationFrame(this.renderScene.bind(this))}}},8743:(e,n,t)=>{"use strict";t.d(n,{Z:()=>s});var i=t(8081),r=t.n(i),o=t(3645),a=t.n(o)()(r());a.push([e.id,".jupyter-ovito {\n    width: auto;\n    height: auto;\n    flex: 1 1 auto;\n}\n\n.jupyter-ovito-toolbtn {\n    width: 30px;\n    height: 30px;\n    border: 0px;\n    display: inline-block;\n    vertical-align: middle;\n    background-color: transparent;\n    background-repeat: no-repeat;\n    background-position: center;\n    padding: 0px;\n}\n\n.jupyter-ovito-toolbtn:hover {\n    background-color: #9a9a9a7a;\n}",""]);const s=a},5418:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main() \n{\n\t// Test if fragment is within the unit circle.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tif(rsq >= 1.0) discard;\n\n    outputFlat(color_fs);\n}'},8135:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nattribute float radius;\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    vec2 dir;\n    if(corner == 0) dir = vec2(-1, -1);\n    else if(corner == 1) dir = vec2(1, -1);\n    else if(corner == 2) dir = vec2(1, 1);\n    else dir = vec2(-1, 1);\n    uv_fs = dir;\n \n    // Transform particle center to view space.\n\tvec3 eye_position = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n    // Apply additional scaling due to model-view transformation to particle radius. \n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * (vec4(eye_position, 1.0) + vec4(dir * viewspace_radius, 0.0, 0.0));\n}'},8686:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main() \n{\n\t// Calculate distance from the circle\'s center.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tfloat r = sqrt(rsq);\n\n\t// For antialiasing, calculate alpha value close to the edge of the circle.\n\tfloat afwidth = fwidth(r);\n\tfloat edge = smoothstep(1.0 - afwidth, 1.0, r);\n\tfloat alpha = 1.0 - edge;\n\n\toutputFlat(vec4(color_fs.rgb, color_fs.a * alpha));\n}'},5235:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 normal_fs;\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n    outputShadedRay(color_fs, normal_fs, ray_dir_norm);\n}'},637:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 normal_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    normal_fs = normalize(normalMatrix * normal);\n\n    raycasting_vertex();\n}'},8132:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\n\nvoid main() \n{\n    outputFlat(color_fs);\n}'},7298:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\nattribute vec4 color1;\nattribute vec4 color2;\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n    // Forward arrow color to fragment shader.\n    color_fs = color1;\n\n    // Arrow in view space.\n    vec3 base_view = (modelViewMatrix * vec4(base, 1.0)).xyz;\n    vec3 head_view = (modelViewMatrix * vec4(head, 1.0)).xyz;\n\n    // Vector pointing from camera to cylinder base in view space:\n\tvec3 view_dir;\n\tif(isOrthographic) {\n\t\tview_dir = vec3(0,0,1);\n    }\n\telse {\n\t\tview_dir = (viewMatrix * vec4(cameraPosition, 1.0)).xyz - base_view;\n    }\n\n    // Arrow radius in view space.\n    float radius_view = radius * length(modelViewMatrix[0]);\n\n\t// Build local coordinate system in view space.\n    mat3 uv_tm;\n\tuv_tm[0] = head_view - base_view;\n    uv_tm[1] = normalize(cross(view_dir, uv_tm[0])) * radius_view;\n    uv_tm[2] = vec3(0);\n\n    vec2 vpos;\n    float arrowHeadRadius = 2.5;\n    float arrowHeadLength = (radius_view * arrowHeadRadius * 1.8) / length(uv_tm[0]);\n    int vidx = gl_VertexID % 7;\n    if(arrowHeadLength < 1.0) {\n        if(vidx == 0) vpos = vec2(1.0, 0.0);\n        else if(vidx == 1) vpos = vec2(1.0 - arrowHeadLength, arrowHeadRadius);\n        else if(vidx == 2) vpos = vec2(1.0 - arrowHeadLength, 1.0);\n        else if(vidx == 3) vpos = vec2(0.0, 1.0);\n        else if(vidx == 4) vpos = vec2(0.0,-1.0);\n        else if(vidx == 5) vpos = vec2(1.0 - arrowHeadLength, -1.0);\n        else if(vidx == 6) vpos = vec2(1.0 - arrowHeadLength, -arrowHeadRadius);\n    }\n    else {\n        if(vidx == 0) vpos = vec2(1.0, 0.0);\n        else if(vidx == 1) vpos = vec2(0.0, arrowHeadRadius / arrowHeadLength);\n        else if(vidx == 6) vpos = vec2(0.0,-arrowHeadRadius / arrowHeadLength);\n        else vpos = vec2(0.0, 0.0);\n    }\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * vec4(base_view + uv_tm * vec3(vpos, 0.0), 1.0);\n}'},6115:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 center;\t// Transformed cone vertex in view coordinates\nvarying vec3 axis;\t\t// Transformed cone axis in view coordinates\nvarying float cone_radius;\t// The radius of the cone\n\nconst float cone_ratio = 1.8; // Ratio of height to radius of arrow head code.\nconst float cone_angle = atan(1.0 / cone_ratio);\nconst float cone_cos_squared = cos(cone_angle) * cos(cone_angle); // squared cosine of the cone angle\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n\n\tfloat zmin;\n\tvec3 ray_origin_shifted = ray_origin;\n\t// This is to improve numeric precision of intersection calculation:\n\tif(isOrthographic) {\n\t\tzmin = dot(ray_dir_norm, ray_origin - center);\n\t\tray_origin_shifted.z = center.z;\n\t}\n\telse {\n\t\tzmin = -cone_radius * cone_ratio;\n\t\tray_origin_shifted += ray_dir_norm * dot(ray_dir_norm, center - ray_origin);\n\t}\n\n\tvec3 axis_normed = normalize(axis);\n\tfloat AdD = dot(axis_normed, ray_dir_norm);\n\tvec3 E = ray_origin_shifted - center;\n\tfloat AdE = dot(axis_normed, E);\n\tfloat DdE = dot(ray_dir_norm, E);\n\tfloat EdE = dot(E, E);\n\tfloat c2 = AdD*AdD - cone_cos_squared;\n\tfloat c1 = AdD*AdE - cone_cos_squared*DdE;\n\tfloat c0 = AdE*AdE - cone_cos_squared*EdE;\n\n\t// Solve the quadratic. Keep only those X for which dot(A,X-V) >= 0.\n\tfloat ray_t = zmin;\n\n\tfloat epsilon = 1e-9 * cone_radius * cone_radius;\n\tif(abs(c2) >= epsilon) {\n\t\tfloat discr = c1*c1 - c0*c2;\n\t\tif(discr < -epsilon) {\n\t\t\t// Q(t) = 0 has no real-valued roots. The ray does not\n\t\t\t// intersect the double-sided cone.\n\t\t\tdiscard;\n\t\t}\n\t\telse if(discr > epsilon) {\n\t\t\t// Q(t) = 0 has two distinct real-valued roots.  However, one or\n\t\t\t// both of them might intersect the portion of the double-sided\n\t\t\t// cone "behind" the vertex.  We are interested only in those\n\t\t\t// intersections "in front" of the vertex.\n\t\t\tfloat root = sqrt(discr);\n\t\t\tfloat height_sq = dot(axis, axis);\n\t\t\tfloat t = (-c1 - root) / c2;\n\t\t\tE = ray_origin_shifted + t * ray_dir_norm - center;\n\t\t\tfloat ddot = dot(E, axis);\n\t\t\tif(ddot > 0.0 && ddot < height_sq && t > zmin) {\n\t\t\t\tray_t = t;\n\t\t\t}\n\t\t\tt = (-c1 + root) / c2;\n\t\t\tvec3 E2 = ray_origin_shifted + t * ray_dir_norm - center;\n\t\t\tddot = dot(E2, axis);\n\t\t\tif(ddot > 0.0 && ddot < height_sq && t > zmin) {\n\t\t\t\tray_t = t;\n\t\t\t\tE = E2;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// One repeated real root (line is tangent to the cone).\n\t\t\tfloat t = -(c1/c2);\n\t\t\tE = ray_origin_shifted + t * ray_dir_norm - center;\n\t\t\tif(dot(E, axis) > 0.0) {\n\t\t\t\tray_t = t;\n\t\t\t}\n\t\t}\n\t}\n\telse if(abs(c1) >= epsilon) {\n\t\t// c2 = 0, c1 != 0 (D is a direction vector on the cone boundary)\n\t\tfloat t = -(0.5*c0/c1);\n\t\tE = ray_origin_shifted + t * ray_dir_norm - center;\n\t\tif(dot(E, axis) > 0.0) {\n\t\t\tray_t = t;\n\t\t}\n\t}\n\telse if(abs(c0) >= epsilon) {\n\t\t// c2 = c1 = 0, c0 != 0\n\t\tdiscard;\n\t}\n\telse if(DdE > 0.0) {\n\t\t// c2 = c1 = c0 = 0, cone contains ray V+t*D where V is cone vertex\n\t\t// and D is the line direction.\n\t\tray_t = DdE;\n\t}\n\tif(ray_t <= zmin)\n\t\tdiscard;\n\n\t// Intersection point with cone:\n\tvec3 view_intersection_pnt = E + center;\n\t// Surface normal at cone intersection point:\n\tvec3 surface_normal = cross(E, cross(E, axis));\n\n\t// Compute intersection with disc.\n\tvec3 disc_center = center + axis;\n\tvec3 normal = axis;\n\tfloat d = -dot(disc_center, normal);\n\tfloat t = -(d + dot(normal, ray_origin_shifted));\n\tfloat td = dot(normal, ray_dir_norm);\n\tt /= td;\n\tif(/*t > zmin && */t < ray_t) {\n\t\tvec3 hitpnt = ray_origin_shifted + t * ray_dir_norm - disc_center;\n\t\tif(dot(hitpnt,hitpnt) < cone_radius*cone_radius) {\n\t\t\tview_intersection_pnt = ray_origin_shifted + t * ray_dir_norm;\n\t\t\tsurface_normal = normal;\n\t\t}\n\t}\n\n\t// Output the ray-cylinder intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n    // Calculate surface normal in view coordinate system.\n    outputShadedRayAndDepth(color_fs, normalize(surface_normal), ray_dir_norm, zdepth);\n}'},8799:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\nattribute vec4 color1;\nattribute vec4 color2;\n\nvarying vec4 color_fs;\nvarying vec3 center;\t// Transformed cone vertex in view coordinates\nvarying vec3 axis;\t\t// Transformed cone axis in view coordinates\nvarying float cone_radius;\t// The radius of the cone\n\nconst float cone_ratio = 1.8; // Ratio of height to radius of arrow head code.\n\nvoid main()\n{\n    // Forward arrow color to fragment shader.\n    color_fs = color1;\n\n    float arrowHeadRadius = 2.5;\n    float arrowHeadLength = cone_ratio * radius * arrowHeadRadius;\n\n    // Reduce original cylinder height to arrow tail length.\n    vec3 vpos = position;\n\n    vec3 arrow_axis = head - base;\n    float len = length(arrow_axis);\n    if(len != 0.0) {\n        if(arrowHeadLength > len) {\n            arrowHeadRadius *= len / arrowHeadLength;\n            arrowHeadLength = len;\n        }\n\n        float h = dot(head - position, arrow_axis) / dot(arrow_axis, arrow_axis);\n        vec3 inplane = (position - base - arrow_axis * (1.0 - h));\n        if(h > 0.5)\n            vpos += (arrowHeadRadius - 1.0) * inplane;\n        else\n            vpos -= inplane;\n\n        float len_offset = (1.0 - arrowHeadLength / len);\n        vpos += arrow_axis * (len_offset * h);\n        arrow_axis *= arrowHeadLength / len;\n    }\n    arrowHeadRadius *= radius;\n\n    // Apply model-view-projection matrix to box vertex position.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vpos, 1.0);\n\n    // Apply additional scaling to cone radius due to model-view transformation. \n\t// Pass square of cylinder radius to fragment shader.\n    cone_radius = arrowHeadRadius * length(modelViewMatrix[0]);\n\n\t// Transform cone to eye coordinates.\n    center = (modelViewMatrix * vec4(head, 1.0)).xyz;\n    axis = (modelViewMatrix * vec4(-arrow_axis, 0.0)).xyz;\n\n    raycasting_vertex();\n}'},4644:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\nattribute vec4 color1;\nattribute vec4 color2;\n\nvarying vec4 color1_fs;\nvarying vec4 color2_fs;\nvarying vec3 cylinder_view_base;\t\t// Transformed cylinder position in view coordinates\nvarying vec3 cylinder_view_axis;\t\t// Transformed cylinder axis in view coordinates\nvarying float cylinder_radius_sq_fs;\t// The squared radius of the cylinder\nvarying float cylinder_length;\t\t\t// The length of the cylinder\n\nconst float cone_ratio = 1.8; // Ratio of height to radius of arrow head code.\n\nvoid main()\n{\n    // Forward cylinder colors to fragment shader.\n    color1_fs = color1;\n    color2_fs = color2;\n\n    float arrowHeadRadius = radius * 2.5;\n    float arrowHeadLength = cone_ratio * arrowHeadRadius;\n\n    // Reduce original cylinder height to arrow tail length.\n    vec3 vpos = position;\n\n    vec3 arrow_axis = head - base;\n    float len = length(arrow_axis);\n    if(len != 0.0) {\n        if(arrowHeadLength > len)\n            arrowHeadLength = len;\n        vpos -= arrow_axis * (arrowHeadLength / len * dot(position - base, arrow_axis) / dot(arrow_axis, arrow_axis));\n        arrow_axis *= (1.0 - arrowHeadLength / len);\n    }\n\n    // Apply model-view-projection matrix to box vertex position.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vpos, 1.0);\n\n    // Apply additional scaling to cylinder radius due to model-view transformation. \n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Pass square of cylinder radius to fragment shader.\n\tcylinder_radius_sq_fs = viewspace_radius * viewspace_radius;\n\n\t// Transform cylinder to eye coordinates.\n\tcylinder_view_base = (modelViewMatrix * vec4(base, 1.0)).xyz;\n\tcylinder_view_axis = (modelViewMatrix * vec4(arrow_axis, 0.0)).xyz;\n\n\t// Pass cylinder length to fragment shader.\n\tcylinder_length = length(cylinder_view_axis);\n\n    raycasting_vertex();\n}'},2293:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nconst int single_cylinder_cap = SINGLE_CYLINDER_CAP;\n\nvarying vec4 color1_fs;\nvarying vec4 color2_fs;\nvarying vec3 cylinder_view_base;\t\t// Transformed cylinder position in view coordinates\nvarying vec3 cylinder_view_axis;\t\t// Transformed cylinder axis in view coordinates\nvarying float cylinder_radius_sq_fs;\t// The squared radius of the cylinder\nvarying float cylinder_length;\t\t\t// The length of the cylinder\n\n#ifdef USE_PSEUDOCOLORS\nuniform sampler2D color_map;\n#endif\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n\n\t// Perform ray-cylinder intersection test.\n\tvec3 n = cross(ray_dir_norm, cylinder_view_axis);\n\tfloat ln = length(n);\n\tvec3 RC = ray_origin - cylinder_view_base;\n\n\tvec3 view_intersection_pnt = ray_origin;\n\tvec3 surface_normal;\n\n\tbool skip = false;\n\tfloat x;\t// Normalized location along cylinder (used for color interpolation). \n\n\tif(ln < 1e-7 * cylinder_length) {\n\t\t// Handle case where view ray is parallel to cylinder axis:\n\n\t\tfloat t = dot(RC, ray_dir_norm);\n\t\tfloat v = dot(RC, RC);\n\t\tif(v-t*t > cylinder_radius_sq_fs) {\n\t\t\tdiscard;\n\t\t}\n\t\telse {\n\t\t\tview_intersection_pnt -= t * ray_dir_norm;\n\t\t\tsurface_normal = -cylinder_view_axis;\n\t\t\tfloat tfar = dot(cylinder_view_axis, ray_dir_norm);\n\t\t\tif(tfar < 0.0 && single_cylinder_cap == 0) {\n\t\t\t\tview_intersection_pnt += tfar * ray_dir_norm;\n\t\t\t\tsurface_normal = cylinder_view_axis;\n\t\t\t\tx = 1.0;\n\t\t\t}\n\t\t\telse x = 0.0;\n\t\t}\n\t}\n\telse {\n\n\t\tn /= ln;\n\t\tfloat d = dot(RC,n);\n\t\td *= d;\n\n\t\t// Test if ray missed the cylinder.\n\t\tif(d > cylinder_radius_sq_fs) {\n\t\t\tdiscard;\n\t\t}\n\t\telse {\n\n\t\t\t// Calculate closest intersection position.\n\t\t\tfloat t = dot(cross(cylinder_view_axis, RC), n) / ln;\n\t\t\tfloat s = abs(sqrt(cylinder_radius_sq_fs - d) / dot(cross(n, cylinder_view_axis), ray_dir_norm) * cylinder_length);\n\t\t\tfloat tnear = t - s;\n\n\t\t\t// Calculate intersection point in view coordinate system.\n\t\t\tview_intersection_pnt += tnear * ray_dir_norm;\n\n\t\t\t// Find intersection position along cylinder axis.\n\t\t\tfloat anear = dot(view_intersection_pnt - cylinder_view_base, cylinder_view_axis) / (cylinder_length*cylinder_length);\n\t\t\tif(anear >= 0.0 && anear <= 1.0) {\n\n\t\t\t\t// Calculate surface normal in view coordinate system.\n\t\t\t\tsurface_normal = (view_intersection_pnt - (cylinder_view_base + anear * cylinder_view_axis));\n\t\t\t\tx = anear;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Calculate second intersection point.\n\t\t\t\tfloat tfar = t + s;\n\t\t\t\tvec3 far_view_intersection_pnt = ray_origin + tfar * ray_dir_norm;\n\t\t\t\tfloat afar = dot(far_view_intersection_pnt - cylinder_view_base, cylinder_view_axis) / (cylinder_length*cylinder_length);\n\n\t\t\t\t// Compute intersection with cylinder caps.\n\t\t\t\tif(anear < 0.0 && afar > 0.0) {\n\t\t\t\t\tview_intersection_pnt += (anear / (anear - afar) * 2.0 * s + 1e-6 * ln) * ray_dir_norm;\n\t\t\t\t\tsurface_normal = -cylinder_view_axis;\n\t\t\t\t\tx = 0.0;\n\t\t\t\t}\n\t\t\t\telse if(anear > 1.0 && afar < 1.0 && single_cylinder_cap == 0) {\n\t\t\t\t\tview_intersection_pnt += ((anear - 1.0) / (anear - afar) * 2.0 * s + 1e-6 * ln) * ray_dir_norm;\n\t\t\t\t\tsurface_normal = cylinder_view_axis;\n\t\t\t\t\tx = 1.0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdiscard;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Output the ray-cylinder intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n\t// Perform linear interpolation of color.\n\tvec4 color = mix(color1_fs, color2_fs, x);\n\n\t// If pseudocolor mapping is used, apply tabulated transfer function to pseudocolor value,\n\t// which is stored in the R component of the input color.\n#ifdef USE_PSEUDOCOLORS\n\tcolor.rgb = texture2D(color_map, color.xy).xyz;\n#endif\n\n    // Calculate surface normal in view coordinate system.\n    outputShadedRayAndDepth(color, normalize(surface_normal), ray_dir_norm, zdepth);\n}'},3568:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\nattribute vec4 color1;\nattribute vec4 color2;\n\nvarying vec4 color1_fs;\nvarying vec4 color2_fs;\nvarying vec3 cylinder_view_base;\t\t// Transformed cylinder position in view coordinates\nvarying vec3 cylinder_view_axis;\t\t// Transformed cylinder axis in view coordinates\nvarying float cylinder_radius_sq_fs;\t// The squared radius of the cylinder\nvarying float cylinder_length;\t\t\t// The length of the cylinder\n\n#ifdef USE_PSEUDOCOLORS\nuniform float color_range_min;\nuniform float color_range_max;\n#endif\n\nvoid main()\n{\n    // Forward cylinder colors to fragment shader.\n    color1_fs = color1;\n    color2_fs = color2;\n\n#ifdef USE_PSEUDOCOLORS\n    color1_fs.x = (color1_fs.x - color_range_min) / (color_range_max - color_range_min);\n    color2_fs.x = (color2_fs.x - color_range_min) / (color_range_max - color_range_min);\n#endif\n\n    // Apply model-view-projection matrix to box vertex position.\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    // Apply additional scaling to cylinder radius due to model-view transformation. \n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Pass square of cylinder radius to fragment shader.\n\tcylinder_radius_sq_fs = viewspace_radius * viewspace_radius;\n\n\t// Transform cylinder to eye coordinates.\n\tcylinder_view_base = (modelViewMatrix * vec4(base, 1.0)).xyz;\n\tcylinder_view_axis = (modelViewMatrix * vec4(head - base, 0.0)).xyz;\n\n\t// Pass cylinder length to fragment shader.\n\tcylinder_length = length(cylinder_view_axis);\n\n    raycasting_vertex();\n}'},6456:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\n\n#ifdef USE_PSEUDOCOLORS\nuniform sampler2D color_map;\n#endif\n\nvoid main()\n{\n#ifndef USE_PSEUDOCOLORS\n    outputFlat(color_fs);\n#else\n\t// If pseudocolor mapping is used, apply tabulated transfer function to pseudocolor value,\n\t// which is stored in the R component of the input color.\n\toutputFlat(texture2D(color_map, color_fs.xy));\n#endif\n}'},8591:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nattribute vec3 base;\nattribute vec3 head;\nattribute float radius;\nattribute vec4 color1;\nattribute vec4 color2;\n\nvarying vec4 color_fs;\n\n#ifdef USE_PSEUDOCOLORS\nuniform float color_range_min;\nuniform float color_range_max;\n#endif\n\nvoid main()\n{\n    // Forward color to fragment shader.\n    color_fs = color1;\n\n#ifdef USE_PSEUDOCOLORS\n    color_fs.x = (color_fs.x - color_range_min) / (color_range_max - color_range_min);\n#endif\n\n    // Arrow in view space.\n    vec3 base_view = (modelViewMatrix * vec4(base, 1.0)).xyz;\n    vec3 head_view = (modelViewMatrix * vec4(head, 1.0)).xyz;\n\n    // Vector pointing from camera to cylinder base in view space:\n\tvec3 view_dir;\n\tif(isOrthographic) {\n\t\tview_dir = vec3(0,0,1);\n    }\n\telse {\n\t\tview_dir = (viewMatrix * vec4(cameraPosition, 1.0)).xyz - base_view;\n    }\n\n    // Arrow radius in view space.\n    float radius_view = radius * length(modelViewMatrix[0]);\n\n\t// Build local coordinate system in view space.\n    mat3 uv_tm;\n\tuv_tm[0] = head_view - base_view;\n    uv_tm[1] = normalize(cross(view_dir, uv_tm[0])) * radius_view;\n    uv_tm[2] = vec3(0);\n\n    vec2 vpos;\n    int vidx = gl_VertexID % 4;\n    if(vidx == 0) vpos = vec2(1.0, -1.0);\n    else if(vidx == 1) vpos = vec2(1.0, 1.0);\n    else if(vidx == 2) vpos = vec2(0.0, 1.0);\n    else vpos = vec2(0.0, -1.0);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * vec4(base_view + uv_tm * vec3(vpos, 0.0), 1.0);\n}'},4617:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying mat3 view_to_sphere_fs;\nvarying mat3 sphere_to_view_fs;\nvarying vec3 particle_view_pos_fs;\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n\tvec3 sphere_dir = view_to_sphere_fs * (particle_view_pos_fs - ray_origin);\n\n\t// Ray direction in sphere coordinate system.\n\tvec3 ray_dir2 = normalize(view_to_sphere_fs * ray_dir);\n\n\t// Perform ray-sphere intersection test.\n\tfloat b = dot(ray_dir2, sphere_dir);\n\tvec3 delta = ray_dir2 * b - sphere_dir;\n\tfloat x = dot(delta, delta);\n\tfloat disc = 1.0 - x;\n\n\t// Only calculate the intersection closest to the viewer.\n\tif(disc < 0.0)\n\t\tdiscard; // Ray missed sphere entirely, discard fragment\n\n\t// Calculate closest intersection position.\n\tfloat tnear = b - sqrt(disc);\n\n\t// Discard intersections located behind the viewer.\n//\tif(tnear < 0.0)\n//\t\tdiscard;\n\n\t// Calculate intersection point in sphere coordinate system.\n\tvec3 sphere_intersection_pnt = tnear * ray_dir2 - sphere_dir;\n\n\t// Calculate intersection point in view coordinate system.\n    vec3 view_intersection_pnt = sphere_to_view_fs * sphere_intersection_pnt + particle_view_pos_fs;\n\n\t// Output the ray-sphere intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n    // Calculate surface normal in view coordinate system.\n    vec3 surface_normal = normalize(sphere_intersection_pnt * view_to_sphere_fs);\n    outputShadedRayAndDepth(color_fs, surface_normal, ray_dir_norm, zdepth);\n}'},2322:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nattribute mat4 shape_orientation;\n\nvarying vec4 color_fs;\nvarying mat3 view_to_sphere_fs;\nvarying mat3 sphere_to_view_fs;\nvarying vec3 particle_view_pos_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    // Pass particle center position to fragment shader.\n\tparticle_view_pos_fs = (modelViewMatrix * shape_orientation[3]).xyz;\n\n    // Matrices for converting to/from unit sphere space.\n    sphere_to_view_fs = mat3(modelViewMatrix) * mat3(shape_orientation);\n    view_to_sphere_fs = inverse(sphere_to_view_fs);\n\n    raycasting_vertex();\n}'},7836:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\n\nvoid main() \n{\n    outputFlat(color_fs);\n}'},9439:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform vec2 line_thickness;\n\nattribute vec3 position2;\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;\n\n\t// Apply model-view-projection matrix to line points.\n\tvec4 proj_from = modelViewProjectionMatrix * vec4(position, 1.0);\n\tvec4 proj_to   = modelViewProjectionMatrix * vec4(position2, 1.0);\n\n\t// Compute line direction vector.\n\tvec2 delta = normalize(proj_to.xy / proj_to.w - proj_from.xy / proj_from.w) * line_thickness;\n\n\t// Correct direction vector if one vertex is behind the viewer the other one in front.\n\tif(proj_to.w * proj_from.w < 0.0)\n\t\tdelta = -delta;\n\n\t// Emit quad vertices.\n\tif(corner == 0)\n\t\tgl_Position = proj_from - vec4(delta.y * proj_from.w, -delta.x * proj_from.w, 0.0, 0.0);\n\telse if(corner == 1)\n\t\tgl_Position = proj_from + vec4(delta.y * proj_from.w, -delta.x * proj_from.w, 0.0, 0.0);\n\telse if(corner == 2)\n\t\tgl_Position = proj_to + vec4(delta.y * proj_to.w, -delta.x * proj_to.w, 0.0, 0.0);\n\telse\n\t\tgl_Position = proj_to - vec4(delta.y * proj_to.w, -delta.x * proj_to.w, 0.0, 0.0);\n}'},7575:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 normal_fs;\n\n#ifdef USE_PSEUDOCOLORS\nuniform sampler2D color_map;\nuniform float opacity;\nuniform vec3 selection_color;\n#endif\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n    \n#ifndef USE_PSEUDOCOLORS\n    outputShadedRay(color_fs, normal_fs, ray_dir_norm);\n#else\n    if(color_fs.y == 0.0) {\n        vec3 color = texture2D(color_map, color_fs.xy).xyz;\n        outputShadedRay(vec4(color, opacity), normal_fs, ray_dir_norm);\n    }\n    else {\n        outputShadedRay(vec4(selection_color, opacity), normal_fs, ray_dir_norm);\n    }\n#endif\n}'},4484:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 normal_fs;\n\n#ifdef USE_PSEUDOCOLORS\nuniform float color_range_min;\nuniform float color_range_max;\n#endif\n\nvoid main()\n{\n#ifndef USE_INSTANCING_COLOR\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n#else\n    color_fs = vec4(instanceColor, 1.0);\n#endif\n\n#ifdef USE_PSEUDOCOLORS\n    color_fs.x = (color_fs.x - color_range_min) / (color_range_max - color_range_min);\n#endif\n\n#ifndef USE_INSTANCING\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    normal_fs = normalize(normalMatrix * normal);\n#else\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);\n    normal_fs = normalize(((viewMatrix * modelMatrix * instanceMatrix) * vec4(normal, 0.0)).xyz);\n#endif\n\n    raycasting_vertex();\n}'},2735:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nuniform vec4 wireframe_color;\n\nvoid main() \n{\n    outputFlat(wireframe_color);\n}'},1717:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvoid main()\n{\n#ifndef USE_INSTANCING\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n#else\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * instanceMatrix * vec4(position, 1.0);\n#endif\n}'},2923:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main() \n{\n\t// Test if fragment is within the unit circle.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tif(rsq >= 1.0) discard;\n\n\t// Calculate surface normal in view coordinate system.\n\tvec3 surface_normal = vec3(uv_fs, sqrt(1.0 - rsq));\n\n\t// Compute local surface color.\n\toutputShadedRay(color_fs, surface_normal, vec3(0.0, 0.0, -1.0));\n}'},3724:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nattribute float radius;\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    vec2 dir;\n    if(corner == 0) dir = vec2(-1, -1);\n    else if(corner == 1) dir = vec2(1, -1);\n    else if(corner == 2) dir = vec2(1, 1);\n    else dir = vec2(-1, 1);\n    uv_fs = dir;\n \n    // Transform particle center to view space.\n\tvec3 eye_position = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n    // Apply additional scaling due to model-view transformation to particle radius. \n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * (vec4(eye_position, 1.0) + vec4(dir * viewspace_radius, 0.0, 0.0));\n}'},5636:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\nvarying vec2 uv_fs;\n\nvoid main() \n{\n\t// Calculate distance from the circle\'s center.\n\tfloat rsq = dot(uv_fs, uv_fs);\n\tfloat r = sqrt(rsq);\n\n\t// For antialiasing, calculate alpha value close to the edge of the circle.\n\tfloat afwidth = fwidth(r);\n\tfloat edge = smoothstep(1.0 - afwidth, 1.0, r);\n\tfloat alpha = 1.0 - edge;\n\n\tif(rsq >= 1.0) discard;\n\n\t// Calculate surface normal in view coordinate system.\n\tvec3 surface_normal = vec3(uv_fs, sqrt(1.0 - rsq));\n\n\t// Compute local surface color.\n\toutputShadedRay(vec4(color_fs.rgb, color_fs.a * alpha), surface_normal, vec3(0.0, 0.0, -1.0));\n}'},8338:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 particle_view_pos_fs;\nvarying float radius_squared;\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n    vec3 sphere_dir = particle_view_pos_fs - ray_origin;\n\n    // Perform ray-sphere intersection test.\n    float b = dot(ray_dir_norm, sphere_dir);\n    vec3 delta = ray_dir_norm * b - sphere_dir;\n    float x = dot(delta, delta);\n    float disc = radius_squared - x;\n\n    if(disc < 0.0)\n        discard; // Ray missed sphere entirely, discard fragment\n\n    // Calculate closest intersection position.\n    float tnear = b - sqrt(disc);\n\n    // Discard intersections located behind the viewer.\n//    if(tnear < 0.0)\n//        discard;\n\n    // Calculate intersection point in view coordinate system.\n    vec3 view_intersection_pnt = ray_origin + tnear * ray_dir_norm;\n\n    // Output the ray-sphere intersection point as the fragment depth\n    // rather than the depth of the bounding box polygons.\n    // The eye coordinate Z value must be transformed to normalized device\n    // coordinates before being assigned as the final fragment depth.\n    vec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n    float fragDepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n    // Calculate surface normal in view coordinate system.\n    vec3 surface_normal = normalize(view_intersection_pnt - particle_view_pos_fs);\n    outputShadedRayAndDepth(color_fs, surface_normal, ray_dir_norm, fragDepth);\n}'},9689:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nattribute float radius;\n\nvarying vec4 color_fs;\nvarying vec3 particle_view_pos_fs;\nvarying float radius_squared;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    particle_view_pos_fs = (modelViewMatrix * vec4(position, 1.0)).xyz;\n    float particle_radius = radius * length(modelViewMatrix[0]);\n    radius_squared = particle_radius * particle_radius;\n\n    vec3 uv;\n    int corner = gl_VertexID % 4;\n    if(!isOrthographic) {\n        // Calculate maximum projection of particle:\n        vec3 sphere_dir = particle_view_pos_fs;\n        float sphere_dist_sq = dot(sphere_dir, sphere_dir);\n        float sphere_dist = sqrt(sphere_dist_sq);\n        float tangent_dist = sqrt(sphere_dist_sq - radius_squared);\n        float alpha = acos(tangent_dist / sphere_dist);\n        vec3 dir = cross(sphere_dir, vec3(0.0, 1.0, 0.0));\n\n        float scaling = sphere_dist * tan(alpha) * sqrt(2.0);\n        if(corner == 0) uv = scaling * normalize(dir);\n        else if(corner == 1) uv = scaling * normalize(cross(dir, sphere_dir));\n        else if(corner == 2) uv = -scaling * normalize(dir);\n        else uv = -scaling * normalize(cross(dir, sphere_dir));\n    }\n    else {\n        float scaling = particle_radius * sqrt(2.0);\n        if(corner == 0) uv = vec3(scaling, 0.0, 0.0);\n        else if(corner == 1) uv = vec3(0.0,  scaling, 0.0);\n        else if(corner == 2) uv = vec3(-scaling, 0.0, 0.0);\n        else uv = vec3(0.0, -scaling, 0.0);\n    }\n\n    gl_Position = projectionMatrix * vec4(particle_view_pos_fs + uv, 1.0);\n\n    raycasting_vertex();\n}'},3268:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying vec3 particle_view_pos_fs;\nvarying float radius_squared;\n\nvoid main() \n{\n    vec3 ray_dir_norm = raycasting_fragment();\n    vec3 sphere_dir = particle_view_pos_fs - ray_origin;\n\n    // Perform ray-sphere intersection test.\n    float b = dot(ray_dir_norm, sphere_dir);\n    vec3 delta = ray_dir_norm * b - sphere_dir;\n    float x = dot(delta, delta);\n    float disc = radius_squared - x;\n\n\tfloat afwidth = fwidth(disc);\n\tfloat alpha = smoothstep(0.0, afwidth, disc);\n    if(disc <= 0.0)\n        discard; // Ray missed sphere entirely, discard fragment\n\n    // Calculate closest intersection position.\n    float tnear = b - sqrt(disc);\n\n    // Discard intersections located behind the viewer.\n//    if(tnear < 0.0)\n//        discard;\n\n    // Calculate intersection point in view coordinate system.\n    vec3 view_intersection_pnt = ray_origin + tnear * ray_dir_norm;\n\n    // Output the ray-sphere intersection point as the fragment depth\n    // rather than the depth of the bounding box polygons.\n    // The eye coordinate Z value must be transformed to normalized device\n    // coordinates before being assigned as the final fragment depth.\n    vec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n    float fragDepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n    // Calculate surface normal in view coordinate system.\n    vec3 surface_normal = normalize(view_intersection_pnt - particle_view_pos_fs);\n    outputShadedRayAndDepth(vec4(color_fs.rgb, alpha), surface_normal, ray_dir_norm, fragDepth);\n}'},798:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n\nvarying vec4 color_fs;\n\nvoid main() \n{\n    outputFlat(color_fs);\n}'},5988:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nattribute float radius;\n\nvarying vec4 color_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    // The index of the quad corner.\n    int corner = gl_VertexID % 4;\n\n    vec2 dir;\n    if(corner == 0) dir = vec2(-1, -1);\n    else if(corner == 1) dir = vec2(1, -1);\n    else if(corner == 2) dir = vec2(1, 1);\n    else dir = vec2(-1, 1);\n \n    // Transform particle center to view space.\n\tvec3 eye_position = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n    // Apply additional scaling due to model-view transformation to particle radius. \n    float viewspace_radius = radius * length(modelViewMatrix[0]);\n\n\t// Project corner vertex.\n    gl_Position = projectionMatrix * (vec4(eye_position, 1.0) + vec4(dir * viewspace_radius, 0.0, 0.0));\n}'},7098:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nconst float ambient = 0.4;\nconst float diffuse_strength = 1.0 - ambient;\nconst float shininess = 6.0;\nconst vec3 specular_lightdir = normalize(vec3(-1.8, 1.5, -0.2));\n\nvoid outputShadedRay(in vec4 color, in vec3 surface_normal, in vec3 ray_dir)\n{\n    float specular = pow(max(0.0, dot(reflect(specular_lightdir, surface_normal), ray_dir)), shininess) * 0.25;\n    float diffuse = abs(surface_normal.z) * diffuse_strength;\n    gl_FragColor = vec4(color.rgb * (diffuse + ambient) + vec3(specular), color.a);\n}\n\nvoid outputShadedRayAndDepth(in vec4 color, in vec3 surface_normal, in vec3 ray_dir, in float zdepth)\n{\n    outputShadedRay(color, surface_normal, ray_dir);\n    gl_FragDepth = zdepth;\n}\n\nvoid outputFlat(in vec4 color)\n{\n    gl_FragColor = color;\n}\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nuniform mat4 projectionMatrix;\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\nvec3 raycasting_fragment()\n{\n    return normalize(ray_dir.xyz / gl_FragCoord.w);\n}\n\n\nvarying vec4 color_fs;\nvarying mat3 view_particle_matrix_fs;\nvarying vec3 particle_view_pos_fs;\nvarying vec2 particle_exponents_fs;\n\nconst int PLANECOUNT = 9;\nconst vec4 planes[PLANECOUNT] = vec4[](\n\tvec4(1.0, 1.0, 0.0, 0.0), \n\tvec4(1.0,-1.0, 0.0, 0.0),\n\tvec4(1.0, 0.0, 1.0, 0.0), \n\tvec4(1.0, 0.0,-1.0, 0.0),\n\tvec4(0.0, 1.0, 1.0, 0.0), \n\tvec4(0.0, 1.0,-1.0, 0.0),\n\tvec4(1.0, 0.0, 0.0, 0.0),\n\tvec4(0.0, 1.0, 0.0, 0.0),\n\tvec4(0.0, 0.0, 1.0, 0.0));\n\nconst float EPSILON = 1.0e-10;\nconst float MIN_VALUE = -1.01;\nconst float MAX_VALUE =  1.01;\nconst float BOUND_HUGE = 2.0e+10;\nconst float DEPTH_TOLERANCE = 1.0e-4; // Minimal intersection depth for a valid intersection.\nconst float ZERO_TOLERANCE = 1.0e-10; // If |x| < ZERO_TOLERANCE, x is regarded to be 0.\nconst int   MAX_ITERATIONS = 20;\n\n/// Intersect a ray with an axis aligned unit box.\nbool intersect_box(in vec3 P, in vec3 D, out float dmin, out float dmax)\n{\n    float tmin = 0.0, tmax = 0.0;\n\n    // Left/right.\n    if(abs(D.x) > EPSILON) {\n        if(D.x > EPSILON) {\n            dmin = (MIN_VALUE - P.x) / D.x;\n            dmax = (MAX_VALUE - P.x) / D.x;\n        }\n        else {\n            dmax = (MIN_VALUE - P.x) / D.x;\n            dmin = (MAX_VALUE - P.x) / D.x;\n        }\n\n        if(dmin > dmax) return false;\n    }\n    else {\n        if((P.x < MIN_VALUE) || (P.x > MAX_VALUE))\n\t\t\treturn false;\n        dmin = -BOUND_HUGE;\n        dmax =  BOUND_HUGE;\n    }\n\n    // Top/bottom.\n    if(abs(D.y) > EPSILON) {\n        if(D.y > EPSILON) {\n            tmin = (MIN_VALUE - P.y) / D.y;\n            tmax = (MAX_VALUE - P.y) / D.y;\n        }\n        else {\n            tmax = (MIN_VALUE - P.y) / D.y;\n            tmin = (MAX_VALUE - P.y) / D.y;\n        }\n\n        if(tmax < dmax) {\n            if(tmin > dmin) {\n                if(tmin > tmax) return false;\n                dmin = tmin;\n            }\n            else {\n                if(dmin > tmax) return false;\n            }\n\n            dmax = tmax;\n        }\n        else {\n            if(tmin > dmin) {\n                if(tmin > dmax) return false;\n                dmin = tmin;\n            }\n        }\n    }\n    else {\n        if((P.y < MIN_VALUE) || (P.y > MAX_VALUE)) {\n            return false;\n        }\n    }\n\n    // Front/back.\n    if(abs(D.z) > EPSILON) {\n        if(D.z > EPSILON) {\n            tmin = (MIN_VALUE - P.z) / D.z;\n            tmax = (MAX_VALUE - P.z) / D.z;\n        }\n        else {\n            tmax = (MIN_VALUE - P.z) / D.z;\n            tmin = (MAX_VALUE - P.z) / D.z;\n        }\n\n        if(tmax < dmax) {\n            if(tmin > dmin) {\n                if(tmin > tmax) return false;\n                dmin = tmin;\n            }\n            else {\n                if(dmin > tmax) return false;\n            }\n\n            dmax = tmax;\n        }\n        else {\n            if(tmin > dmin) {\n                if(tmin > dmax) return false;\n                dmin = tmin;\n            }\n        }\n    }\n    else {\n        if((P.z < MIN_VALUE) || (P.z > MAX_VALUE)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfloat evaluate_g(in float x, in float y, in float e)\n{\n    float g = 0.0;\n\n    if(x > y) {\n        g = 1.0 + pow(y / x, e);\n        if(g != 1.0)\n            g = pow(g, 1.0 / e);\n        g *= x;\n    }\n    else if(y != 0.0) {\n        g = 1.0 + pow(x / y, e);\n        if(g != 1.0)\n            g = pow(g, 1.0 / e);\n        g *= y;\n    }\n\n    return g;\n}\n\n/// Computes the superellipsoid value at the given location.\nfloat evaluate_superellipsoid(in vec3 P)\n{\n    return evaluate_g(evaluate_g(abs(P.x), abs(P.y), particle_exponents_fs.x), abs(P.z), particle_exponents_fs.y) - 1.0;\n}\n\n// Home in on the root of a superquadric using a combination of secant and bisection methods.  \n// This routine requires that the sign of the function be different at P0 and P1, it will fail drastically if this isn\'t the case.\nvoid solve_hit1(in float v0, in vec3 tP0, in float v1, in vec3 tP1, out vec3 P)\n{\n    int i;\n    float x, v2, v3;\n    vec3 P0, P1, P2, P3;\n\n    P0 = tP0;\n    P1 = tP1;\n\n    // The sign of v0 and v1 changes between P0 and P1, this means there is an intersection point in there somewhere.\n    for(i = 0; i < MAX_ITERATIONS; i++) {\n        if(abs(v0) < ZERO_TOLERANCE) {\n            // Near point is close enough to an intersection - just use it.\n            P = P0;\n            break;\n        }\n\n        if(abs(v1) < ZERO_TOLERANCE) {\n            // Far point is close enough to an intersection.\n            P = P1;\n            break;\n        }\n\n        // Look at the chord connecting P0 and P1.\n        // Assume a line between the points.\n        x = abs(v0) / abs(v1 - v0);\n        P2 = P1 - P0;\n        P2 = P0 + x * P2;\n        v2 = evaluate_superellipsoid(P2);\n\n        // Look at the midpoint between P0 and P1.\n        P3 = P1 - P0;\n        P3 = P0 + 0.5 * P3;\n        v3 = evaluate_superellipsoid(P3);\n\n        if(v2 * v3 < 0.0) {\n            // We can move both ends.\n            v0 = v2;\n            P0 = P2;\n            v1 = v3;\n            P1 = P3;\n        }\n        else {\n            if(abs(v2) < abs(v3)) {\n                // secant method is doing better.\n                if(v0 * v2 < 0.0) {\n                    v1 = v2;\n                    P1 = P2;\n                }\n                else {\n                    v0 = v2;\n                    P0 = P2;\n                }\n            }\n            else {\n                // bisection method is doing better.\n                if(v0 * v3 < 0.0) {\n                    v1 = v3;\n                    P1 = P3;\n                }\n                else {\n                    v0 = v3;\n                    P0 = P3;\n                }\n            }\n        }\n    }\n\n    if(i == MAX_ITERATIONS) {\n        // The loop never quite closed in on the result - just use the point\n        // closest to zero.  This really shouldn\'t happen since the max number\n        // of iterations is enough to converge with straight bisection.\n        if(abs(v0) < abs(v1)) {\n            P = P0;\n        }\n        else {\n            P = P1;\n        }\n    }\n}\n\n\n/// Try to find the root of a superquadric using Newtons method.\nbool check_hit2(in vec3 P, in vec3 D, in float t0, inout vec3 P0, in float v0, in float t1, out float t, out vec3 Q)\n{\n    int i;\n    float dt0, dt1, v1, deltat, maxdelta;\n\n\tconst float eps = 1.0e-5;\n\n    dt0 = t0;\n    dt1 = t0 + 1.0e-4 * (t1 - t0);\n    maxdelta = t1 - t0;\n\n    for(i = 0; (dt0 < t1) && (i < MAX_ITERATIONS); i++) {\n        vec3 P1 = P + dt1 * D;\n        v1 = evaluate_superellipsoid(P1);\n\n        if(v0 * v1 < 0.0) {\n            // Found a crossing point, go back and use normal root solving.\n            solve_hit1(v0, P0, v1, P1, Q);\n            P0 = Q - P;\n            t = length(P0);\n            return true;\n        }\n        else {\n            if(abs(v1) < eps) {\n                Q = P + dt1 * D;\n                t = dt1;\n                return true;\n            }\n            else {\n                if(((v0 > 0.0) && (v1 > v0)) || ((v0 < 0.0) && (v1 < v0))) {\n                    // We definitely failed.\n                    break;\n                }\n                else {\n                    if(v1 == v0) {\n                        break;\n                    }\n                    else {\n                        deltat = v1 * (dt1 - dt0) / (v1 - v0);\n                    }\n                }\n            }\n        }\n\n        if(abs(deltat) > maxdelta) {\n            break;\n\t\t}\n\n        v0 = v1;\n        dt0 = dt1;\n        dt1 -= deltat;\n    }\n\n    return false;\n}\n\nvoid main()\n{\n    // Calculate ray passing through the fragment (in view space).\n    vec3 ray_dir_norm = raycasting_fragment();\n\n\tvec3 ray_origin_shifted = ray_origin;\n\t// This is to improve numeric precision of intersection calculation:\n\tif(isOrthographic)\n\t\tray_origin_shifted.z = particle_view_pos_fs.z;\n\n    // Transform the ray into the superellipsoid space.\n\tvec3 P = view_particle_matrix_fs * (ray_origin_shifted - particle_view_pos_fs);\n\tvec3 D = view_particle_matrix_fs * ray_dir_norm;\n\tfloat len = length(D);\n\tD /= len;\n\n    // Intersect bounding box.\n\tfloat t1, t2;\n    if(!intersect_box(P, D, t1, t2)) {\n\t\tdiscard;\n\t}\n\n    // Test if superellipsoid lies \'behind\' the ray origin.\n\tif(!isOrthographic) {\n\t\tif(t2 < DEPTH_TOLERANCE)\n\t\t\tdiscard;\n\t\tif(t1 < DEPTH_TOLERANCE)\n\t\t\tt1 = DEPTH_TOLERANCE;\n\t}\n\telse {\n\t\t// When using parallel projection, make sure intersection point is always at t>0 by shifting the ray base point.\n\t\tif(t1 < DEPTH_TOLERANCE) {\n\t\t\tP -= D * (DEPTH_TOLERANCE - t1);\n\t\t\tray_origin_shifted -= ray_dir_norm * ((DEPTH_TOLERANCE - t1) / len);\n\t\t\tt2 += DEPTH_TOLERANCE - t1;\n\t\t\tt1 = DEPTH_TOLERANCE;\n\t\t}\n\t}\n\n\tint cnt = 2;\n    float dists[PLANECOUNT + 2];\n    dists[0] = t1;\n    dists[1] = t2;\n\n    // Intersect ray with planes cutting superellipsoids in pieces.\n\t// Find all the places where the ray intersects the set of\n\t// subdividing planes through the superquadric.  Return the\n\t// number of valid hits (within the bounding box).\n\n    // Since min and max dist are the distance to two of the bounding planes\n    // we are considering, there is a high probablity of missing them due to\n    // round off error. Therefore we adjust min and max.\n    float margin = EPSILON * (t2 - t1);\n    float mindist = t1 - margin;\n    float maxdist = t2 + margin;\n\n    // Check the sets of planes that cut apart the superquadric.\n\tint i;\n    for(i = 0; i < PLANECOUNT; i++) {\n        float d = dot(D, planes[i].xyz);\n\n        if(abs(d) < EPSILON)\n            continue; // Can\'t possibly get a hit for this combination of ray and plane.\n\n        float t = (planes[i].w - dot(P, planes[i].xyz)) / d;\n\n        if((t >= mindist) && (t <= maxdist)) {\n            dists[cnt++] = t;\n        }\n    }\n\n    // Sort the results for further processing.\n\t// Todo: Replace this bubble sort implemention with something more efficient.\n\tbool done;\n\tdo {\n\t\tdone = true;\n\t\tfor(i = 1; i < cnt; i++) {\n\t\t\tif(dists[i] < dists[i-1]) {\n\t\t\t\tfloat temp = dists[i];\n\t\t\t\tdists[i] = dists[i-1];\n\t\t\t\tdists[i-1] = temp;\n\t\t\t\tdone = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!done);\n\n\tvec3 P0 = P + dists[0] * D;\n\tfloat v0 = evaluate_superellipsoid(P0);\n\n\tfloat tnear = BOUND_HUGE;\n\tif(abs(v0) < ZERO_TOLERANCE) {\n\t\ttnear = dists[0] / len;\n\t}\n\telse {\n\t\tfor(i = 1; i < cnt; i++) {\n\t\t\tvec3 P1 = P + dists[i] * D;\n\t\t\tfloat v1 = evaluate_superellipsoid(P1);\n\n\t\t\tif(abs(v1) < ZERO_TOLERANCE) {\n\t\t\t\ttnear = dists[i] / len;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(v0 * v1 < 0.0) {\n\t\t\t\t\t// Opposite signs: there must be a root between.\n\t\t\t\t\tvec3 P2;\n\t\t\t\t\tsolve_hit1(v0, P0, v1, P1, P2);\n\t\n\t\t\t\t\tvec3 P3 = P2 - P;\n\t\t\t\t\tfloat t = length(P3);\n\n\t\t\t\t\ttnear = t / len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Although there was no sign change, we may actually be approaching\n\t\t\t\t\t// the surface. In this case, we are being fooled by the shape of the\n\t\t\t\t\t// surface into thinking there isn\'t a root between sample points.\n\t\t\t\t\tfloat t;\n\t\t\t\t\tvec3 P2;\n\t\t\t\t\tif(check_hit2(P, D, dists[i-1], P0, v0, dists[i], t, P2)) {\n\t\t\t\t\t\ttnear = t / len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv0 = v1;\n\t\t\tP0 = P1;\n\t\t}\n\t}\n\n\t// Discard intersections behind the view point.\n\tif(tnear == BOUND_HUGE || tnear < 0.0) {\n\t\tdiscard;\n\t}\n\n\t// Calculate intersection point in view coordinate system.\n\tvec3 view_intersection_pnt = ray_origin_shifted + tnear * ray_dir_norm;\n\n\t// Output the ray-sphere intersection point as the fragment depth\n\t// rather than the depth of the bounding box polygons.\n\t// The eye coordinate Z value must be transformed to normalized device\n\t// coordinates before being assigned as the final fragment depth.\n\tvec4 projected_intersection = projectionMatrix * vec4(view_intersection_pnt, 1.0);\n\tfloat zdepth = (projected_intersection.z / projected_intersection.w + 1.0) * 0.5;\n\n\t// Intersection point in the superellipsoid space.\n\tP += D * (tnear * len);\n\n\t// Calculate surface normal in superellipsoid space.\n\tfloat r, z2n = 0.0;\n\tif(P.z != 0.0) {\n\t\tz2n = pow(abs(P.z), particle_exponents_fs.y);\n\t\tP.z = z2n / P.z;\n\t}\n\n\tif(abs(P.x) > abs(P.y)) {\n\t\tr = pow(abs(P.y / P.x), particle_exponents_fs.x);\n\t\tP.x = (1.0 - z2n) / P.x;\n\t\tP.y = (P.y != 0.0) ? (1.0 - z2n) * r / P.y : 0.0;\n\t}\n\telse if(P.y != 0.0) {\n\t\tr = pow(abs(P.x / P.y), particle_exponents_fs.x);\n\t\tP.x = (P.x != 0.0) ? (1.0 - z2n) * r / P.x : 0.0;\n\t\tP.y = (1.0 - z2n) / P.y;\n\t}\n\t\n\tif(P.z != 0.0)\n\t\tP.z *= (1.0 + r);\n\n\t// Transform the normal from superellipsoid space to view space.\n\tvec3 surface_normal = normalize(P * view_particle_matrix_fs);\n\n    outputShadedRayAndDepth(color_fs, surface_normal, ray_dir_norm, zdepth);\n}\n'},538:e=>{e.exports='////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////\n//\n//  Copyright 2022 OVITO GmbH, Germany\n//\n//  This file is part of OVITO (Open Visualization Tool).\n//\n//  OVITO is free software; you can redistribute it and/or modify it either under the\n//  terms of the GNU General Public License version 3 as published by the Free Software\n//  Foundation (the "GPL") or, at your option, under the terms of the MIT License.\n//  If you do not alter this notice, a recipient may use your version of this\n//  file under either the GPL or the MIT License.\n//\n//  You should have received a copy of the GPL along with this program in a\n//  file LICENSE.GPL.txt.  You should have received a copy of the MIT License along\n//  with this program in a file LICENSE.MIT.txt\n//\n//  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,\n//  either express or implied. See the GPL or the MIT License for the specific language\n//  governing rights and limitations.\n//\n////////////////////////////////////////////////////////////////////////////////////////\n\nvarying vec3 ray_origin;\nvarying vec3 ray_dir;\n\n// This function is used called by vertex or geometry shaders to calculate the ray (in view space)\n// that goes through the current vertex. The interpolated output is used by the fragment shader to\n// calculate the view ray going through each fragment. \nvoid raycasting_vertex()\n{\n    mat4 inverse_projection_matrix = inverse(projectionMatrix); \n    vec2 viewport_position = vec2(gl_Position.x / gl_Position.w, gl_Position.y / gl_Position.w);\n    vec4 near = inverse_projection_matrix * vec4(viewport_position, -1.0, 1.0);\n    vec4 far = near + inverse_projection_matrix[2];\n    ray_origin = near.xyz / near.w * gl_Position.w;\n    ray_dir = (far.xyz / far.w - near.xyz / near.w) * gl_Position.w;\n}\n\n\nattribute mat4 shape_orientation;\nattribute vec2 roundness;\n\nvarying vec4 color_fs;\nvarying mat3 view_particle_matrix_fs;\nvarying vec3 particle_view_pos_fs;\nvarying vec2 particle_exponents_fs;\n\nvoid main()\n{\n#if defined( USE_COLOR_ALPHA )\n    color_fs = color;\n#elif defined( USE_COLOR )\n    color_fs = vec4(color, 1.0);\n#else\n    color_fs = vec4(1.0);\n#endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    // Pass ellipsoid matrix and center position to fragment shader.\n\tparticle_view_pos_fs = (modelViewMatrix * shape_orientation[3]).xyz;\n    view_particle_matrix_fs = inverse(mat3(modelViewMatrix) * mat3(shape_orientation));\n\n\t// The x-component of the input vector is exponent \'e\', the y-component is \'n\'.\n\tparticle_exponents_fs.x = 2.0 / (roundness.x > 0.0 ? roundness.x : 1.0);\n\tparticle_exponents_fs.y = 2.0 / (roundness.y > 0.0 ? roundness.y : 1.0);\n\n    raycasting_vertex();\n}'},4147:e=>{"use strict";e.exports={version:"0.1.4"}}}]);